<!-- Imports polymer -->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../vaadin-grid/vaadin-grid.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-sorter.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-selection-column.html">
<link rel="import" href="../paper-search/paper-search.html">

<!-- Defines element markup -->
<dom-module id="actindo-grid">
    <template>
        <style>
            :host {
                display: block;
                box-sizing: border-box;
                height: 100%;
                width: 100%;
                padding: 0;
                margin: 0;
            }

            .toolbar {
                align-items: center;
                display: flex;
                justify-content: space-between;
                width: 100%;
            }
                .toolbar .title {
                    flex-grow: 1;
                }

                paper-search-bar {
                    color: var(--actindo-font-color);
                }

            vaadin-grid {
                border-top: 2px solid var(--actindo-primary);
                height: 100%;
            }
        </style>

        <paper-toolbar>
            <div slot="top" class="toolbar">
                <slot name="toolbar"></slot>
                <div class="title"></div>
                <paper-search-bar placeholder="Schnellsuche"
                                  query="{{searchValue}}"
                                  nr-selected-filters="[[selectedFilters.length]]"
                                  on-paper-search-search="search"
                                  on-paper-search-clear="search"
                                  on-paper-search-filter="openFilters"
                                  hide-filter-button="[[!filters.length]]"></paper-search-bar>
                <paper-filter-dialog id="filterDialog" filters="[[filters]]"
                                     selected-filters="{{selectedFilters}}"
                                     on-save="search"></paper-filter-dialog>
            </div>
        </paper-toolbar>

        <vaadin-grid id="grid"
                     selected-items="{{selectedItems}}"
                     size="{{size}}"
                     column-reordering-allowed="{{columnReorderingAllowed}}"
                     multi-sort="[[multiSort]]"
                     style="min-width: 500px; height:100%;">
            <slot></slot>
        </vaadin-grid>
    </template>

    <!-- Registers custom element -->
    <script>
        Polymer({
            is: 'actindo-grid',


            properties: {
                loadUrl: {
                    type: String,
                    notify: false,
                    readOnly: false
                },

                /**
                 * The array of selected items of the grid
                 *
                 * Convenience property, as the selection object is
                 * at least difficult to handle using declarative data binding alone
                 *
                 * Warning: will only contain the first 500 selected rows.
                 *
                 * @property {Array<object>} columns
                 * @type {Array<object>}
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: []
                },

                /**
                 * when true, it's possible to order by multiple columns
                 *
                 * @property {Boolean} multiSort
                 * @default false
                 * @type {Boolean}
                 */
                multiSort: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Explicitly sets the number of records the `items` array/function
                 * provides for the grid to display.
                 *
                 * This may also be set indirectly by passing the value as the second
                 * parameter for data request callback function.
                 *
                 * @property {Number} size
                 * @type {Number}
                 */
                size: {
                    type: Number,
                    value: 50
                },

                /**
                 * Boolean property to set whether column reordering is allowed by the grid.
                 *
                 * @property {boolean} columnReorderingAllowed
                 * @default false
                 * @type {boolean}
                 */
                columnReorderingAllowed: {
                    type: Boolean,
                    value: false
                },

                /**
                 * contains all the calculated filters from the contained columns
                 *
                 * @property {Array} filters
                 * @type Array
                 */
                filters: {
                    type: Array,
                    notify: true,
                    value: []
                }
            },

            searchValue: '',
            selectedFilters: [],

            /**
             * Clears the gridâ€™s internal data cache, causing it to request the
             * visible items in the grid viewport from the `items` property or the
             * `datasource` function.
             *
             * Needs to be called whenever the data items are modified in some way
             * (added, removed, updated, re-ordered etc.).
             *
             * @type {Function}
             */
            refreshItems: function() {
                this.$.grid.clearCache();
            },

            _dump: function(e) {
                console.log(e);
            },

            clearInput: function () {
                this.searchValue = '';
                this.$.grid.clearCache();
            },

            search: function () {
                this.$.grid.clearCache();
            },

            openFilters: function () {
                this._calculatePossibleFilters();
                this.$.filterDialog.open();
            },

            _calculatePossibleFilters: function() {
                var filters = [];

                var filterableColumns = Array.from(this.querySelectorAll('vaadin-grid-column[filter]'));
                filterableColumns.forEach(function(column, index) {
                    var filter = {
                        id: column.getAttribute('filter-column'),
                        name: column.getAttribute('filter-label'),
                        type: column.getAttribute('filter')
                    };
                    if(filter.type === 'values')
                    {
                        filter.values = [];
                    }

                    filters.push(filter);
                });

                this.filters = filters;
            },


            ready: function () {
                var me = this;
                var grid = me.grid = this.$.grid;

                this._calculatePossibleFilters();

                grid.dataProvider = me.delegateBuffered(function (params, callback) {
                    var url = me.loadUrl + '?start=' + (params.page * params.pageSize) +
                                           '&limit=' + params.pageSize;
                    if (params.sortOrders) {
                        for(var i = 0; i < params.sortOrders.length; i++) {
                            var s = params.sortOrders[i];
                            url +=
                                    '&sort[' + i + '][field]=' + s.path +
                                    '&sort[' + i + '][order]=' + (s.direction === 'asc' ? 'ASC' : 'DESC');
                        }
                    }
                    var selectedFilters = [];
                    for (var i in me.filters) {
                        var f = me.filters[i];
                        var id = f.id;
                        if (id in me.selectedFilters) {
                            if (!f.type || f.type === 'values') {
                                selectedFilters.push({property: id, operator: 'in', value: me.selectedFilters[id]});
                            }
                            else if (f.type === 'string') {
                                selectedFilters.push({
                                    property: id,
                                    operator: 'like',
                                    value: me.selectedFilters[id]
                                });
                            }
                            else if (f.type === 'boolean') {
                                selectedFilters.push({
                                    property: id,
                                    operator: '=',
                                    value: me.selectedFilters[id] ? 1 : 0
                                });
                            }
                        }
                    }
                    url += me.toQueryString(selectedFilters, 'filter');
                    if (me.searchValue.length) {
                        url += '&query=' + encodeURIComponent(me.searchValue);
                        url += '&fields[]=controllerMethod';
                    }
                    var xhr = new XMLHttpRequest();
                    xhr.onreadystatechange = function () {
                        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
                            var response = JSON.parse(xhr.responseText);
                            me.size = response.data.length;
                            callback(response.data, response.n_rows);
                        }
                    };

                    xhr.open('GET', url, true);
                    xhr.send();
                }, 200);
            },

            toQueryString: function (object, base) {
                var queryString = [];
                var me = this;

                Object.keys(object).forEach(function (key) {

                    var result,
                            value;

                    value = object[key];

                    if (base) {
                        key = base + '[' + key + ']';
                    }
                    switch (typeof value) {
                        case 'object':
                            result = me.toQueryString(value, key);
                            break;
                        case 'array':
                            var qs = {};
                            value.forEach(function (val, i) {
                                qs[i] = val;
                            });
                            result = me.toQueryString(qs, key);
                            break;
                        default:
                            result = key + '=' + encodeURIComponent(value);
                    }

                    if(value !== null) {
                        queryString.push(result);
                    }
                });
                return queryString.join('&');
            },

            delegateBuffered: function (func, buffer) {
                var timer;

                return function () {
                    var callArgs = arguments,
                            me = this;

                    if (timer) {
                        clearTimeout(timer);
                    }

                    timer = setTimeout(function () {
                        func.apply(me, callArgs);
                    }, buffer);
                };
            }
        });
    </script>
</dom-module>
