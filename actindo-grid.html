<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="actindo-grid-cell-content.html">
<link rel="import" href="actindo-grid-column-configurator.html">
<link rel="import" href="actindo-grid-search.html">

<!--
`<actindo-grid>` implements a highly reusable data grid to display your data.

### Features

- column configuration as property, therefore dynamic column changes are propagated through data binding
- global search bar (hidden if no column is configured to be `searchable`)
- filter panel (hidden if no column is configured to be `filterable`)
- sorting (by every column that is configured to be `sortable`)
- pagination as long as a `remote` is specified to fetch data from
- remote loading of data, including sorting, paging, searching, filtering
- static data display (disables pagination)
- custom cell formatting through `render` callbacks
- hidden columns that can be shown manually

-->
<dom-module id="actindo-grid">
    <template>
        <style>
            :host {
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: hidden;
                width: 100%;
            }
            :host[hidden] {
                display: none;
            }

            table {
                border-collapse: collapse;
                min-width: 100%;
                table-layout: fixed;
            }
                table th {
                    border: none;
                    color: transparent;
                    font-weight: normal;
                    line-height: 0;
                    padding: 0;
                    text-align: left;
                }
                    th.sortable-true {
                        cursor: pointer;
                    }
                    th.is-sorted-true,
                    th.is-sorted-false {
                        font-weight: 500;
                    }
                    th.sortable-true div.th span:after {
                        background: url(data:image/svg+xml;charset=utf-8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3C%21DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20version%3D%221.1%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M11%2C4H13V16L18.5%2C10.5L19.92%2C11.92L12%2C19.84L4.08%2C11.92L5.5%2C10.5L11%2C16V4Z%22%20%2F%3E%3C%2Fsvg%3E) no-repeat center center;
                        background-size: contain;
                        content: "";
                        display: inline-block;
                        height: 16px;
                        margin-left: 0.25em;
                        opacity: 0;
                        vertical-align: text-bottom;
                        width: 16px;
                        transition: transform 150ms 150ms, opacity 150ms;
                        transform: rotate(180deg);
                    }
                    th.is-sorted-true div.th span:after { /* sorted ASC */
                        opacity: 0.74;
                        transform: rotate(180deg);
                    }
                    th.is-sorted-false div.th span:after { /* sorted DESC */
                        opacity: 0.74;
                        transform: rotate(0deg);
                        transition: transform 150ms, opacity 150ms;
                    }
                td {
                    opacity: 1;
                    padding: 0.95em 0.75em;
                    transition: opacity 150ms;
                }

                th, td {
                    border: solid var(--actindo-border-dark);
                    border-width: 1px 0;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                    tr:last-of-type td,
                    tbody tr:first-of-type td {
                        border: 0;
                    }
                tr td.checkbox {
                    position: relative;
                }
                tr td.checkbox iron-icon {
                    left: 1em;
                    opacity: 0;
                    position: absolute;
                    top: 0.7em;
                    transition: opacity 150ms;
                }
                tr td.checkbox paper-checkbox {
                    background-color: rgba(0, 0, 0, 0);
                    border-radius: 0;
                    height: 18px;
                    position: relative;
                    transform: scale(1, 1);
                    transition: background-color 150ms, border-radius 150ms, transform 150ms;
                    width: 18px;
                }
                tr[selected] {
                    background-color: var(--actindo-light-grey);
                }
                tr:hover {
                    background-color: var(--actindo-primary-light);
                }
                tr[disabled],
                tr[locked] td {
                    background-color: transparent;
                    cursor: auto;
                    opacity: 0.34;
                }
                tr[locked] td:first-child {
                    opacity: 1;
                }
                tr[locked] td.checkbox paper-checkbox {
                    transform: scale(0.5, 0.5);
                }
                tr[locked] td.checkbox iron-icon {
                    opacity: 1;
                }
                tr[finished] td.checkbox paper-checkbox {
                    background-color: var(--actindo-primary);
                    border-radius: 50%;
                    text-indent: -5em;
                }

            div.th {
                box-sizing: border-box;
                border-bottom: 1px solid var(--actindo-border-dark);
                color: #000;
                line-height: 60px;
                padding: 0 0.75em;
                position: absolute;
                top: 0;
            }
                div.th span {
                    display: block;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }

            th.checkbox,
            td.checkbox,
            div.checkbox {
                box-sizing: content-box;
                max-width: 32px;
                min-width: 32px;
                overflow: visible;
                text-align: center;
                text-overflow: clip;
                width: 32px;
            }

            .filler {
                width: auto;
            }

            #toggleAll {
                position: relative;
                left: -1px;
            }
                #toggleAll:after {
                    background: #000;
                    content: "";
                    display: block;
                    font-weight: bold;
                    height: 2px;
                    left: 6px;
                    opacity: 0;
                    position: absolute;
                    top: 8px;
                    transition: opacity 200ms;
                    width: 6px;
                }
                #toggleAll[partial]:after {
                    opacity: 1;
                }

            input[type="checkbox"] {
                cursor: pointer;
            }

            table tbody tr {
                cursor: pointer;
            }
            table.disable-tap-row-select-true tbody tr {
                cursor: auto;
            }

            #fixed {
                display: flex;
                overflow-x: auto;
                padding-top: 60px;
                position: relative;
                flex-grow: 1;
            }

            #grid {
                background-color: #fff;
                overflow-y: auto;
                width: 100%;
            }

            #toolbar {
                align-items: center;
                display: flex;
                max-height: 4.7em;
                min-height: 4.7em;
                justify-content: space-between;
            }

            .sizer {
                bottom: 0;
                cursor: col-resize;
                position: absolute;
                right: 0;
                top: 0;
                width: 6px;
            }
            .sizer.active {
                transform: scale(10, 1.2);
                transform-origin: 50% 50%;
                z-index: 1;
            }

            #paging {
                align-items: center;
                border-top: 1px solid var(--actindo-border-dark);
                display: flex;
                justify-content: flex-end;
                max-height: 4.15em;
                min-height: 4.15em;
            }
            #paging[hidden] {
                display: none;
            }
                #paging > div {
                    opacity: 0.54;
                }

            paper-icon-button[hidden] {
                display: none;
            }
        </style>

        <div id="toolbar">
            <div>
                <slot name="toolbar"></slot>
            </div>
            <div id="actions">
                <actindo-grid-search query="{{query}}" hidden$="[[!remote]]"></actindo-grid-search>
                <paper-icon-button icon="refresh" hidden$="[[!remote]]" on-tap="refresh"></paper-icon-button>
                <actindo-grid-column-configurator columns="{{_columns}}" hidden="[[hideColumnConfiguration]]"></actindo-grid-column-configurator>
            </div>
        </div>
        <div id="fixed">
            <div id="grid">
                <table class$="disable-tap-row-select-[[disableTapRowToSelect]]" id="table">
                    <thead on-tap="_onHeadTapped">
                        <tr>
                            <template is="dom-if" if="[[_stringEquals(selectionMode, 'multi', 'single')]]" id="toggleAllIf">
                                <th class="checkbox">
                                    <div class="th checkbox">
                                        <paper-checkbox id="toggleAll" partial$="[[_partiallySelected]]" checked="[[_everythingSelected]]" hidden="[[!_stringEquals(selectionMode, 'multi')]]" on-checked-changed="_toggleAllSelection"></paper-checkbox>
                                        &nbsp;
                                    </div>
                                </th>
                            </template>
                            <template is="dom-repeat" items="{{_columns}}" filter="_isColumnVisibile" observe="hidden" id="headerRepeat">
                                <th data-index$="[[index]]" class$="c[[index]] sortable-[[item.sortable]] is-sorted-[[_isSortedBy(item, sort)]]">
                                    <div class="th">
                                        <span>[[item.label]]</span>
                                        <template is="dom-if" if="[[_evaluatesTrue(item.resizable)]]">
                                            <div class="sizer"></div>
                                        </template>
                                    </div>
                                    [[item.label]]
                                </th>
                            </template>
                            <th class="filler"></th>
                        </tr>
                    </thead>
                    <tbody>
                        <template is="dom-repeat" items="[[items]]" as="row">
                            <tr on-tap="_onRowTap"
                                disabled$="[[_propertyEvaluatesTrue(disabledField, row.*)]]"
                                selected$="[[_isItemSelected(row, selectedItems.*)]]"
                                finished$="[[_propertyEvaluatesTrue(finishedField, row.*)]]"
                                locked$="[[_propertyEvaluatesTrue(lockedField, row.*)]]">
                                <template is="dom-if" if="[[_stringEquals(selectionMode, 'multi', 'single')]]">
                                    <td class="checkbox">
                                        <paper-checkbox checked="[[_isItemSelected(row, selectedItems.*)]]"></paper-checkbox>
                                        <iron-icon icon="lock"></iron-icon>
                                    </td>
                                </template>
                                <template is="dom-repeat" items="{{_columns}}" as="column" filter="_isColumnVisibile" observe="hidden">
                                    <td class$="c[[index]]" style$="[[_getColumnWidth(index)]]"><actindo-grid-cell-content row="[[row]]" column="[[column]]"></actindo-grid-cell-content></td>
                                </template>
                                <td></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="paging" hidden="[[!remote]]">
            <div>
                [[_getItemsFrom(page, itemsPerPage)]]-[[_getItemsTo(page, itemsPerPage, totalItems)]] of [[totalItems]]
                <paper-icon-button disabled="[[!_canPageBackward(page)]]" icon="first-page" on-tap="firstPage"></paper-icon-button>
                <paper-icon-button disabled="[[!_canPageBackward(page)]]" icon="chevron-left" on-tap="previousPage"></paper-icon-button>
                <paper-icon-button disabled="[[!_canPageForward(page, itemsPerPage, totalItems)]]" icon="chevron-right" on-tap="nextPage"></paper-icon-button>
                <paper-icon-button disabled="[[!_canPageForward(page, itemsPerPage, totalItems)]]" icon="last-page" on-tap="lastPage"></paper-icon-button>
            </div>
        </div>
    </template>
    <script>
        class ActindoGrid extends Polymer.Element {
            static get is() { return 'actindo-grid'; }

            static get properties() {
                return {
                    /**
                     * contains the columns and their configuration.
                     * * label: the name of this column, used in the header
                     * * field: data index where this columns value is located
                     * * type: the data type of this column, can be any valid javascript type
                     * * identifying: if this column contains a unique key that identifies the single rows. _One_ column must have this if you want to use a selection mode
                     * * hidden: if this column is hidden by default and needs to be enabled manually
                     * * searchable: if this field is searched through the global search field. Defaults to false
                     * * sortable: if the grid can by sorted by this field. Defaults to false
                     * * filterable: if the grid can be filtered by this columns values
                     * * resizable: if this column is resizable
                     * * render: Optional callback that is given the columns value for each row and has to return a DOMElement to be displayed
                     *
                     * @type {[{
                     *     label: string,
                     *     field: string,
                     *     type: mixed,
                     *     identifying: bool,
                     *     hidden: bool,
                     *     searchable: bool,
                     *     sortable: bool,
                     *     filterable: bool,
                     *     resizable: bool,
                     *     render: function
                     * }]}
                     */
                    columnConfiguration: {
                        type: Array,
                        value: []
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is disabled
                     */
                    disabledField: {
                        type: String,
                        value: '_disabled'
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is marked as finished.
                     * This only works with a selection mode enabled since the marker replaces the checkbox
                     */
                    finishedField: {
                        type: String,
                        value: '_finished'
                    },

                    /**
                     * the current page number
                     */
                    page: {
                        type: Number,
                        value: 1,
                        notify: true,
                        observer: '_onPageChanged'
                    },

                    /**
                     * contains the current sorting criteria, the key "field" contains the field name, the field "order" a boolean: true is ASC, false is DESC
                     * {field: String, order: Boolean}
                     */
                    sort: {
                        type: Object,
                        value: {},
                        notify: true
                    },

                    /**
                     * contains the current search query
                     */
                    query: {
                        type: String,
                        value: '',
                        notify: true,
                        observer: '_onQueryChanged'
                    },

                    /**
                     * stores the number of total items (over all pages)
                     */
                    totalItems: {
                        type: Number,
                        value: 0,
                        notify: true,
                        readOnly: true
                    },

                    /**
                     * if this is true, the column selection switch is hidden and the user can not enable/disable or rearrange columns
                     */
                    hideColumnConfiguration: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * contains all items that are currently in the grid. You can set this property to manually
                     * handle the content of the grid in case you don't want to use the remote loading
                     */
                    items: {
                        type: Array,
                        value: [],
                        notify: true
                    },
                    
                    /**
                     * how mny items to show per page
                     */
                    itemsPerPage: {
                        type: Number,
                        value: 25
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is marked as locked.
                     */
                    lockedField: {
                        type: String,
                        value: '_locked'
                    },

                    /**
                     * the url to load items from. Alternatively you can use the property `items` to manually add data to the grid,
                     * however that disables the possibility to search, filter, or sort
                     */
                    remote: {
                        type: String,
                        value: null
                    },

                    /**
                     * where the items array is located in the remote response.
                     */
                    remotePathData: {
                        type: String,
                        value: 'data'
                    },

                    /**
                     * where the total count of items is located in the remote response.
                     */
                    remotePathCount: {
                        type: String,
                        value: 'n_rows'
                    },

                    /**
                     * this url param is added to the `remote` url containing the user selected filters
                     */
                    remoteParamFilter: {
                        type: String,
                        value: 'filter'
                    },

                    /**
                     * this url param is added to the `remote` url containing the number of items to be loaded
                     */
                    remoteParamLimit: {
                        type: String,
                        value: 'limit'
                    },

                    /**
                     * this url param is added to the `remote` url containing the requested page
                     */
                    remoteParamOffset: {
                        type: String,
                        value: 'start'
                    },

                    /**
                     * this url param is added to the `remote` url containing the search phrase the user entered
                     */
                    remoteParamSearch: {
                        type: String,
                        value: 'query'
                    },

                    /**
                     * this url param is added to the `remote` url containing the fields that should be searched for `query`
                     */
                    remoteParamSearchFields: {
                        type: String,
                        value: 'fields'
                    },

                    /**
                     * this url parameter is added to the `remote` url containing the user selected sorting. Set this
                     * to null to sort the data locally
                     */
                    remoteParamSort: {
                        type: String,
                        value: 'sort'
                    },

                    /**
                     * how rows can be selected. "multi" to allow the selection of n elements, "single" to allow the
                     * selection of only a single element (selecting a new one will deselect the previously selected one).
                     * Any other value will disable the selection model entirely.
                     * If a selection mode is enabled, a checkbox is added to the start of each row
                     */
                    selectionMode: {
                        type: String
                    },

                    /**
                     * if selectionMode=single, this property contains the selected item if one is selected
                     */
                    selectedItem: {
                        type: Object,
                        notify: true,
                        observer: 'onSelectedItemChanged'
                    },

                    /**
                     * contains all the currently selected items
                     */
                    selectedItems: {
                        type: Array,
                        value: [],
                        notify: true
                    },
                    
                    /**
                     * if this is enabled and a selection mode is active, tapping a row will not select it. Rows can then
                     * only be selected by explicitely checking their checkboxes
                     */
                    disableTapRowToSelect: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * internal property that holds the processed columns
                     */
                    _columns: {
                        type: Array,
                        value: []
                    },

                    /**
                     * holds the colmumn that is marked as identifying
                     */
                    _identifyingColumn: {
                        type: Object
                    },

                    /**
                     * property that controls the checked state of the "select all checkbox" in selectionMode=multi
                     */
                    _everythingSelected: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * property that indicates if a partial selection is active (at least one item, but not all)
                     */
                    _partiallySelected: {
                        type: Boolean,
                        value: false
                    }
                };
            }



            /*
             * public api
             */

            /**
             * loads the first page
             */
            firstPage() {
                this.page = 1;
            }

            /**
             * loads the last page
             */
            lastPage() {
                this.page = Math.max(1, Math.ceil(this.totalItems / this.itemsPerPage));
            }

            /**
             * loads the next page
             */
            nextPage() {
                this.page = Math.max(1, Math.min(this.page + 1, Math.ceil(this.totalItems / this.itemsPerPage)));
            }

            /**
             * loads the previous page
             */
            previousPage() {
                this.page = Math.max(1, this.page - 1);
            }

            /**
             * reloads the grid data from the remote
             */
            refresh() {
                this._onRemoteChanged(
                    this.remote,
                    this.remotePathData,
                    this.remotePathCount,
                    this.remoteParamFilter,
                    this.remoteParamLimit,
                    this.remoteParamOffset,
                    this.remoteParamSearch,
                    this.remoteParamSearchFields,
                    this.remoteParamSort,
                    this.itemsPerPage,
                    this.page,
                    this.sort,
                    this.query
                );
            }



            /*
             * lifecycle and initialization
             */

            static get observers() {
                return [
                    '_consolidateColumns(columnConfiguration.*)',
                    '_onItemsChanged(items.*)',
                    '_onSelectionChanged(selectedItems.*)',
                    '_onRemoteChanged(remote, remotePathData, remotePathCount, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, itemsPerPage, page, sort, query)'
                ];
            }

            ready() {
                super.ready();
                let me = this;

                window.setTimeout(function() {
                    me._initColumnResizing();
                }, 0);
            }

            /**
             * returns the default configuration for a column
             *
             * @returns {{}}
             */
            static get columnDefaults() {
                return {
                    label: '',
                    field: '',
                    type: String,
                    identifying: false,
                    hidden: false,
                    searchable: false,
                    sortable: false,
                    filterable: false,
                    resizable: true,
                    render: null
                };
            }

            /**
             * sets up the column resizing handlers
             * @private
             */
            _initColumnResizing() {
                let me = this;

                this.resizingColumns = undefined;
                this.resizingColumnOffset = 0;
                this.resizingHandle = undefined;
                this.$.grid.addEventListener('mousedown', function(e) {
                    if(e.target.classList && e.target.classList.contains('sizer')) {
                        e.target.classList.add('active');
                        me.resizingHandle = e.target;
                        let column = e.target.parentNode.parentNode;
                        let selectIndex = column.getAttribute('data-index');
                        me.resizingColumns = Polymer.dom(me.root).querySelectorAll('.c' + selectIndex);
                        me.resizingColumnOffset = column.offsetWidth - e.pageX;
                        for(let i = 0, c = me.resizingColumns.length; i < c; i++) {
                            let resizeChild = me.resizingColumns[i].getElementsByClassName('th')[0];
                            if(resizeChild) {
                                me.resizingColumns[i].resizeChild = resizeChild;
                            }
                            else {
                                me.resizingColumns[i].resizeChild = null;
                            }
                        }
                    }
                });
                document.addEventListener('mousemove', function(e) {
                    if(me.resizingColumns && me.resizingColumns.length) {
                        let paddedWidth = Math.max(me.resizingColumnOffset + e.pageX, 32);
                        let width = paddedWidth - 19.5; // -19.5 is the width of the columns left/right padding
                        let styleText = 'width: ' + width + 'px; min-width: ' + width + 'px; max-width: ' + width + 'px;';
                        let styleTextPadded = 'width: ' + paddedWidth + 'px; min-width: ' + paddedWidth + 'px; max-width: ' + paddedWidth + 'px;';
                        for(let i = 0, c = me.resizingColumns.length; i < c; i++)
                        {
                            if(me.resizingColumns[i].tagName === 'TH') {
                                me.resizingColumns[i].setAttribute('style', styleTextPadded);
                            }
                            else {
                                me.resizingColumns[i].setAttribute('style', styleText);
                            }
                            if(me.resizingColumns[i].resizeChild) {
                                width += 19.5;
                                me.resizingColumns[i].resizeChild.setAttribute('style', styleTextPadded);
                            }
                        }
                    }
                });
                document.addEventListener('mouseup', function(e) {
                    me.resizingColumns = undefined;
                    if(me.resizingHandle) {
                        me.$.grid.setAttribute('style', 'width: ' + me.$.table.clientWidth + 'px; min-width: ' + me.$.table.clientWidth + 'px; max-width: ' + me.$.table.clientWidth + 'px;');
                        me.resizingHandle.classList.remove('active');
                    }
                    me.resizingHandle = undefined;
                });

                // set initial column widths
                let heads = Polymer.dom(me.root).querySelectorAll('th');
                let i = 0, c = heads.length;
                let interval = window.setInterval(function() {
                    i = me.selectionMode ? 1 : 0;
                    for(; i < c; i++)
                    {
                        if(i < c-1) {
                            let width = heads[i].clientWidth;
                            if(width < 1) {
                                return;
                            }
                            let styleString = 'max-width: ' + width + 'px; min-width: ' + width + 'px; width: ' + width + 'px';
                            heads[i].setAttribute('style', styleString);
                            let div = heads[i].getElementsByClassName('th')[0];
                            if(div) {
                                div.setAttribute('style', styleString);
                            }
                        }
                        window.clearInterval(interval);
                    }
                    me.$.grid.style.width = me.$.table.clientWidth + 'px';
                    me._sizeColumnsByHeaders();
                }, 50);
            }



            /*
             * event callbacks
             */

            /**
             * called when the table head is tapped. Check if the tapped column is sortable and if so, sort by it
             * @private
             */
            _onHeadTapped(e) {
                let column;
                for(let i = 0, c = e.path.length; i < c; i++) {
                    if(i > 5 || !e.path[i].classList) {
                        return;
                    }
                    if(e.path[i].classList.contains('sortable-true')) {
                        column = e.path[i];
                        break;
                    }
                }

                column = this._columns[column.getAttribute('data-index')];
                if(column)
                {
                    let field = column.field;
                    if(!this.sort.hasOwnProperty('field'))
                    {
                        // currently no sorting, sort by the given column ASC
                        this.set('sort', {field: field, order: true});
                    }
                    else
                    {
                        // a sorting is defined
                        if(this.sort.field !== field) {
                            // currently sorted by differen field, sort by this field asc
                            this.set('sort', {field: field, order: true});
                        }
                        else if(this.sort.order === true) {
                            // currently sorted asc by this field, sort desc by this field now
                            this.set('sort', {field: field, order: false});
                        }
                        else {
                            // currently sorted desc by this field, remove sorting
                            this.set('sort', {});
                        }
                    }
                }
            }

            /**
             * called when the property `query` changes. Set page to 1
             * @private
             */
            _onQueryChanged() {
                this.firstPage();
            }

            /**
             * called when a row in the table is tapped. If row tapping should select the row and a selection mode
             * is active, the tapped row is selected
             * @private
             */
            _onRowTap(e) {
                e.stopPropagation();
                if(!this.selectionMode || (e.target.tagName !== 'PAPER-CHECKBOX' && this.disableTapRowToSelect))
                {
                    return;
                }
                let index = e.model.index;
                let row = this.items[index];

                if(this._propertyEvaluatesTrue(this.disabledField, this.items[index])) {
                    // field is disabled, no interaction possible
                    return;
                }
                if(this._propertyEvaluatesTrue(this.lockedField, this.items[index])) {
                    // field is locked, no interaction possible
                    return;
                }
                if(this._propertyEvaluatesTrue(this.finishedField, this.items[index])) {
                    // field is finished, no interaction possible
                    return;
                }

                let rowSelectedIndex = this.selectedItems.indexOf(row);
                if(rowSelectedIndex > -1)
                {
                    this.splice('selectedItems', rowSelectedIndex, 1);
                    this.set('selectedItem', null);
                }
                else
                {
                    if(this.selectionMode === 'single') {
                        this.set('selectedItems', [this.items[index]]);
                        this.set('selectedItem', this.items[index]);
                    }
                    else
                    {
                        this.push('selectedItems', this.items[index]);
                    }
                }
            }

            /**
             * called when the selected item changes (selection mode = single). Updates the selectedItems property
             *
             * @param {{}} newVal the newly selected item
             */
            onSelectedItemChanged(newVal) {
                if(this.selectionMode !== 'single') {
                    return;
                }

                this.set('selectedItems', [newVal]);
            }

            /**
             * called when the "select all" checkbox is tapped. Toggles the selection of all items
             * @private
             */
            _toggleAllSelection() {
                if(this._everythingSelected)
                {
                    this.set('selectedItems', []);
                }
                else
                {
                    if(!this.items) {
                        this.set('selectedItems', []);
                    }
                    else {
                        let selected = [];
                        for(let i = 0, c = this.items.length; i < c; i++)
                        {
                            selected.push(this.items[i]);
                        }
                        this.set('selectedItems', selected);
                    }
                }
            }

            /**
             * called when the items property changes. Move it to _items and make sure to properly
             * propagate the change.
             * Unfortunately a copy of th original item has to be created to make polymer aware of this change.
             *
             * @param {{path: String, base: []}} change
             * @private
             */
            _onItemsChanged(change) {
                var rowsWereAdded = false;

                if(change.path === 'items.splices')
                {
                    change.value.indexSplices.forEach(function(operation) {
                        rowsWereAdded = rowsWereAdded || operation.addedCount > 0;
                    });
                }

                let me = this;
                if(rowsWereAdded || (change.path === 'items' && change.value && change.value.length > 0)) {
                    window.setTimeout(function() {
                        me._sizeColumnsByHeaders();
                    }, 0);
                }

                // update selectedItems: check if the items that were selected are still the grid and are not disabled or locked
                this.__selectionDebounce = this.__selectionDebounce | 0;
                window.clearTimeout(this.__selectionDebounce);
                this.__selectionDebounce = window.setTimeout(function() {
                    let newSelectedItems = [];
                    me.selectedItems.forEach(function(item) {
                        if(me.items.indexOf(item) !== -1) {
                            if(me._propertyEvaluatesTrue(me.lockedField, item)) {
                                // item is locked, no longer selected
                                return;
                            }
                            if(me._propertyEvaluatesTrue(me.disabledField, item)) {
                                // item is disabled, no longer selected
                                return;
                            }
                            if(me._propertyEvaluatesTrue(me.finishedField, item)) {
                                // item is finished, no longer selected
                                return;
                            }
                            newSelectedItems.push(item);
                        }
                    });
                    if(me.selectedItem && newSelectedItems.indexOf(me.selectedItem) === -1) {
                        // selectedItem is no longer in the array of selected items (and therefor not in the grid, remove it)
                        me.set('selectedItem', null);
                    }
                    me.set('selectedItems', newSelectedItems);
                }, 5);
            }

            /**
             * called when a new page is set. Make sure it's within the possible bounds
             *
             * @param {Number} newVal
             * @private
             */
            _onPageChanged(newVal) {
                if(this.totalItems > 0 && this.itemsPerPage > 0)
                {
                    this.page = Math.max(1, Math.min(this.page, Math.ceil(this.totalItems / this.itemsPerPage)));
                }
            }

            /**
             * called when the selected items change. Fires an event
             * @private
             */
            _onSelectionChanged() {
                this._everythingSelected = (this.selectedItems.length > 0 && this.selectedItems.length === this.items.length);
                this._partiallySelected = this.selectedItems.length > 0 && !this._everythingSelected;
                this.dispatchEvent(new CustomEvent('selected-items-changed', {detail: {path: 'selectedItems', value: this.selectedItems}}));
            }

            /**
             * called when the columnConfiguration changes. Process the columns and copy them to the internal
             * _columns property.
             *
             * @param {{base: []}} columnConfiguration
             * @private
             */
            _consolidateColumns(columnConfiguration) {
                let configuration = columnConfiguration.base;

                let columns = [];

                this._identifyingColumn = null;

                for(let i = 0, c = configuration.length; i < c; i++)
                {
                    let item = ActindoGrid.columnDefaults;

                    for(let key in configuration[i]) {
                        item[key] = configuration[i][key];
                    }

                    if(item.identifying)
                    {
                        if(this._identifyingColumn !== null)
                        {
                            console.warn('more than one identifying columns given, ignoring this', item);
                        }
                        else
                        {
                            this._identifyingColumn = item;
                        }
                    }

                    columns.push(item);
                }

                if(this._identifyingColumn === null && this.selectionMode) {
                    console.warn('no identifying column given, disabling selection model', columns);
                    this.selectionMode = null;
                }

                this._columns = columns;
            }

            /**
             * called on explicit refresh or if any of the parameter changes that require a reload from the remote
             *
             * @private
             */
            _onRemoteChanged(remote, remotePathData, remotePathCount, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, itemsPerPage, page, sort, query) {
                if(!remote) {
                    return;
                }

                let me = this;
                let request = {};

                // pagination
                request[remoteParamLimit] = itemsPerPage;
                request[remoteParamOffset] = (page - 1) * itemsPerPage;

                // sorting
                if(sort.hasOwnProperty('field')) {
                    request[remoteParamSort] = [];
                    request[remoteParamSort].push({field: sort.field, order: sort.order ? 'ASC' : 'DESC'});
                }

                // searching
                if(query.length) {
                    request[remoteParamSearch] = query;
                    request[remoteParamSearchFields] = [];
                    for(let i = 0, c = me._columns.length; i < c; i++) {
                        let column = me._columns[i];
                        if(column.searchable) {
                            request[remoteParamSearchFields].push(column.field);
                        }
                    }
                }

                return fetch(remote, {
                    method: 'POST',
                    credentials: 'same-origin',
                    body: me._serialize(request)
                }).then(function(response) {
                    return response.json();
                }).then(function(json) {
                    me.items = Polymer.Path.get(json, remotePathData);
                    me._setTotalItems(Polymer.Path.get(json, remotePathCount));
                }).catch(function(error) {
                    console.error('error loading data', error);
                });
            }



            /*
             * internal helpers
             */

            /**
             * takes the given object and creates an http query string from it
             * usage: let str = _serialize({foo: 'bar', baz: ['a', 'b']}); => 'foo=bar&baz[0]=a&baz[1]=b'
             *
             * @param {{}} obj the object to serialize
             * @param {String} prefix internal only (used in recursive calls for nested objects)
             * @returns {String}
             * @private
             */
            _serialize(obj, prefix) {
                var str = [], p;
                for(p in obj) {
                    if (obj.hasOwnProperty(p)) {
                        var k = prefix ? prefix + "[" + p + "]" : p, v = obj[p];
                        str.push((v !== null && typeof v === "object") ?
                            this._serialize(v, k) :
                            encodeURIComponent(k) + "=" + encodeURIComponent(v));
                    }
                }
                return str.join("&");
            }

            /**
             * sets the width of all grid cells to the width of its headers. This is sometimes required, for example when adding
             * new rows: without setting an explicit width they are autosized and may end up blowing up the width of the entire column
             *
             * @private
             */
            _sizeColumnsByHeaders() {
                let dom = Polymer.dom(this.root);
                var headers = dom.querySelectorAll('th[data-index]');
                for(let i = 0, c = headers.length; i < c; i++) {
                    let index = headers[i].getAttribute('data-index');
                    if(!index) {
                        continue;
                    }
                    let width = parseInt(headers[i].style.width) - 19.5;
                    if(isNaN(width)) {
                        return;
                    }
                    let styleString = 'max-width: ' + width + 'px; min-width: ' + width + 'px; width: ' + width + 'px';
                    let columnRows = dom.querySelectorAll('.c' + index);
                    for(let j = 1, d = columnRows.length; j < d; j++) {
                        columnRows[j].setAttribute('style', styleString);
                    }
                }
            }





            /*
             * template helpers
             */

            /**
             * checks if the user can page backwards
             *
             * @param {Number} page the current page
             * @returns {Boolean}
             * @private
             */
            _canPageBackward(page) {
                return page > 1;
            }

            /**
             * checks if the user can page forwards
             *
             * @param {Number} page the current page
             * @param {Number} itemsPerPage how many items per page should be shown
             * @param {Number} totalItems how mnay items are in the grid in total
             * @returns {Boolean}
             * @private
             */
            _canPageForward(page, itemsPerPage, totalItems) {
                return this._getItemsTo(page, itemsPerPage, totalItems) < totalItems;
            }

            /**
             * calculates the offset for the pagination query
             *
             * @param {Number} page the page to calculate the offset for
             * @param {Number} itemsPerPage how many items per page should be shown
             * @returns {Number}
             * @private
             */
            _getItemsFrom(page, itemsPerPage) {
                return (page - 1) * itemsPerPage + 1;
            }

            /**
             * returns the index of the last item on the given page
             * @param {Number} page the pag to calculate the last index for
             * @param {Number} itemsPerPage how many items per page should be shown
             * @param totalItems
             * @private
             */
            _getItemsTo(page, itemsPerPage, totalItems) {
                return Math.min(page * itemsPerPage, totalItems);
            }

            /**
             * checks if the given value evaluates to true
             *
             * @param value
             * @returns {boolean}
             * @private
             */
            _evaluatesTrue(value) {
                return Boolean(value);
            }

            /**
             * determines if the given column is visible
             *
             * @param {{hidden: bool}} column
             * @returns {boolean}
             * @private
             */
            _isColumnVisibile(column) {
                return !column.hidden;
            }

            /**
             * checks if the given item is selected
             *
             * @param {{}} item one item from the current data array
             * @param {[]} selectedItems an array of currently selected items
             * @returns {boolean}
             * @private
             */
            _isItemSelected(item, selectedItems) {
                return selectedItems.base.indexOf(item) > -1;
            }
            
            /**
             * checks if the grid is currently sorted by the given column
             *
             * @param {{field: String}} column the column to check
             * @param {{field: String}} sort the current sorting array
             * @returns {Boolean}
             * @private
             */
            _isSortedBy(column, sort) {
                if(sort.hasOwnProperty('field') && sort.field === column.field) {
                    return sort.order;
                }

                return null;
            }

            /**
             * determines if the given field evaluates to true in the given item.
             *
             * @param {String} field
             * @param {{}} item
             */
            _propertyEvaluatesTrue(field, item) {
                if(item.hasOwnProperty('base')) {
                    item = item.base;
                }

                if(item.hasOwnProperty(field)) {
                    return Boolean(item[field]);
                }

                return false;
            }

            /**
             * checks if the given string equals one or more given strings. The first given parameter is the value to
             * look for, it is compared with oll other given params and if one of them matches, true is returned; otherwise
             * false
             *
             * @returns {boolean}
             * @private
             */
            _stringEquals() {
                let test = arguments[0];
                for(let i = 1, c = arguments.length; i < c; i++)
                {
                    if(arguments[i] === test)
                    {
                        return true;
                    }
                }

                return false;
            }

            /**
             * helper to determine the width of newly rendered cells
             *
             * @param {Number} index the index of the column
             * @returns {String} a css string defining the width
             * @private
             */
            _getColumnWidth(index) {
                var header = Polymer.dom(this.root).querySelector('th.c' + index);
                if(!header) {
                    return '';
                }
                let width = parseInt(header.style.width) - 19.5;
                return 'max-width: ' + width + 'px; min-width: ' + width + 'px; width: ' + width + 'px';
            }
        }

        customElements.define(ActindoGrid.is, ActindoGrid);
    </script>
</dom-module>