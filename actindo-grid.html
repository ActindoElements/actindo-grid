<link rel="import" href="../../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="actindo-grid-cell-content.html">
<link rel="import" href="actindo-grid-search.html">
<link rel="import" href="actindo-grid-filter-helper.html">
<link rel="import" href="actindo-grid-filter-in-option-input.html">
<link rel="import" href="actindo-grid-filter-edit.html">
<link rel="import" href="actindo-grid-filter.html">
<link rel="import" href="actindo-grid-filter-between-input.html">
<link rel="import" href="actindo-grid-filter-in-input.html">
<link rel="import" href="actindo-grid-filter-item.html">
<link rel="import" href="actindo-grid-filter-tag.html">
<link rel="import" href="actindo-grid-error.html">
<link rel="import" href="actindo-grid-filter-configurator.html">
<link rel="import" href="actindo-grid-filter-form.html">
<link rel="import" href="actindo-grid-filter-columns.html">

<!--
`<actindo-grid>` implements a highly reusable data grid to display your data.

### Features

- column configuration as property, therefore dynamic column changes are propagated through data binding
- global search bar (hidden if no column is configured to be `searchable`)
- filter panel (hidden if no column is configured to be `filterable`)
- sorting (by every column that is configured to be `sortable`)
- pagination as long as a `remote` is specified to fetch data from
- remote loading of data, including sorting, paging, searching, filtering
- static data display (disables pagination)
- custom cell formatting through `render` callbacks
- hidden columns that can be shown manually

-->
<dom-module id="actindo-grid">
    <template>
        <style include="actindo-level-style"></style>
        <style>

            :host {
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: hidden;
                width: 100%;
                --settings-style: {
                    background-color: var(--actindo-level0-d1);
                    color: var(--actindo-level2);
                };
                --filter-tag-container: {
                    background-color: var(--actindo-level0);
                    color: var(--actindo-level2);
                };
                --filter-tag: {
                    --paper-checkbox-unchecked-color: var(--actindo-light-grey-light);
                    --paper-checkbox-checkmark-color: var(--actindo-primary);
                    --paper-checkbox-checked-color: var(--actindo-highlight);
                };
                --no-checkbox-style:
                {
                    --container-background-color: var(--actindo-level0);
                    color: var(--actindo-level2);
                };
                --checkbox-style: {
                    --inactive-background-color:
                    --inactive-color: asdasd;
                }
                --background-color: white;
                --hover-color: var(--actindo-primary-light);
                --selected-color: var(--actindo-primary);
                background-color: var(--background-color);
                --border-color: var(--actindo-secondary-30);
                --menu-background-color: var(--actindo-light-grey-70);

            }
            :host[hidden] {
                display: none;
            }

            actindo-grid-filter-columns, actindo-grid-filter
            {
                @apply(--settings-style);
            }


            :host([embedded])
            {
                --background-color: var(--actindo-light-grey-30);
                --hover-color: var(--actindo-light-grey-70);
                --selected-color: var(--actindo-light-grey-50);
                --border-color: var(--actindo-secondary-30);
                border-radius: 5px;
                border: 1px solid var(--border-color);
            }

            ::-webkit-scrollbar {
                width: 10px;
                height: 10px;
                padding-right: 5px;
            }
            ::-webkit-scrollbar-track {
                background: transparent;
            }
            ::-webkit-scrollbar-track:hover {
                background: rgba(0,0,0,0.15);
            }
            ::-webkit-scrollbar-thumb {
                background-color: var(--actindo-secondary-light);
                border-right: 2px solid var(--actindo-secondary-light);
                border-left: 2px solid var(--actindo-secondary-light);
            }

            ::-webkit-scrollbar-thumb:hover {
                background-color: var(--actindo-secondary);
                border-right: 2px solid var(--actindo-secondary);
                border-left: 2px solid var(--actindo-secondary);
            }

            [hidden] 
            {
                display: none !important;
            }

            table {
                border-collapse: collapse;
                min-width: 100%;
                table-layout: fixed;
            }
                table th {
                    border: none;
                    color: transparent;
                    font-weight: normal;
                    line-height: 0;
                    padding: 0 0.75em;
                    text-align: left;
                }
                    th.sortable-true {
                        cursor: pointer;
                    }
                    th.is-sorted-true,
                    th.is-sorted-false {
                        font-weight: 500;
                    }
                    th.sortable-true div.th span:after {
                        background: url(data:image/svg+xml;charset=utf-8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3C%21DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20version%3D%221.1%22%20width%3D%2224%22%20height%3D%2224%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M11%2C4H13V16L18.5%2C10.5L19.92%2C11.92L12%2C19.84L4.08%2C11.92L5.5%2C10.5L11%2C16V4Z%22%20%2F%3E%3C%2Fsvg%3E) no-repeat center center;
                        background-size: contain;
                        content: "";
                        display: inline-block;
                        height: 16px;
                        margin-left: 0.25em;
                        opacity: 0;
                        vertical-align: text-bottom;
                        width: 16px;
                        transition: transform 150ms 150ms, opacity 150ms;
                        transform: rotate(180deg);
                    }
                    th.is-sorted-true div.th span:after { /* sorted ASC */
                        opacity: 0.74;
                        transform: rotate(180deg);
                    }
                    th.is-sorted-false div.th span:after { /* sorted DESC */
                        opacity: 0.74;
                        transform: rotate(0deg);
                        transition: transform 150ms, opacity 150ms;
                    }
                td {
                    opacity: 1;
                    padding: 0.95em 0.75em;
                    transition: opacity 150ms;
                }

                th, td {
                    border: solid var(--border-color);
                    border-width: 1px 0 0 0;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
                    /*tr:last-of-type td,*/
                    tbody tr:first-of-type td {
                        border: 0;
                    }
                tr td.checkbox {
                    position: relative;
                }
                tr td.checkbox iron-icon {
                    left: 1em;
                    opacity: 0;
                    position: absolute;
                    top: 0.7em;
                    transition: opacity 150ms;
                }
                tr td.checkbox paper-checkbox {
                    background-color: rgba(0, 0, 0, 0);
                    border-radius: 0;
                    height: 18px;
                    position: relative;
                    transform: scale(1, 1);
                    transition: background-color 150ms, border-radius 150ms, transform 150ms;
                    width: 18px;
                }
                tr[selected] {
                    background-color: var(--selected-color);
                }
                #gridBody tr:hover {
                    background-color: var(--hover-color);
                }
                tr[disabled],
                tr[locked] td {
                    color: var(--disabled-color);
                    background-color: var(---primary-background-color);
                    cursor: auto;
                    opacity: 0.34;
                }
                tr[locked] td:first-child {
                    opacity: 1;
                }
                tr[locked] td.checkbox paper-checkbox {
                    transform: scale(0.5, 0.5);
                }
                tr[locked] td.checkbox iron-icon {
                    opacity: 1;
                }
                tr[finished] td.checkbox paper-checkbox {
                    background-color: var(--selected-color);
                    border-radius: 50%;
                    text-indent: -5em;
                }

            div.th {
                box-sizing: border-box;
                color: #000;
                line-height: 60px;
                position: relative;
            }
            div.th span {
                display: block;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            th.checkbox,
            td.checkbox,
            div.checkbox {
                box-sizing: content-box;
                max-width: 32px;
                min-width: 32px;
                overflow: visible;
                text-align: center;
                text-overflow: clip;
                width: 32px;
            }

            .filler {
                width: auto;
            }

            #toggleAll {
                position: relative;
                left: 6px;
            }
                #toggleAll:after {
                    background: #000;
                    content: "";
                    display: block;
                    font-weight: bold;
                    height: 2px;
                    left: 6px;
                    opacity: 0;
                    position: absolute;
                    top: 8px;
                    transition: opacity 200ms;
                    width: 6px;
                }
                #toggleAll[partial]:after {
                    opacity: 1;
                }

            input[type="checkbox"] {
                cursor: pointer;
            }

            table tbody tr {
                cursor: pointer;
            }
            table.disable-tap-row-select-true tbody tr {
                cursor: auto;
            }

            table tbody
            {
                position: relative;
            }

            .loading
            {
                position: absolute;
                top: 0;
                left:0;
                right: 0;
                bottom: 0;
                background-color: var(--primary-background-color);
                opacity: 0.72;
                display: flex;
                align-items: center;
                z-index: 1;
                justify-content: center;
            }

            #gridBody {
                overflow: auto;
                position: relative;
                background-color: var(--background-color);
                display: flex;
                flex-grow: 1;
                flex-direction: column;
            }

            #toolbar {
                align-items: center;
                /*background: linear-gradient(-90deg, #fff 0%, var(--actindo-primary), var(--actindo-primary), var(--actindo-primary), var(--actindo-primary)) no-repeat;*/
                background: transparent;
                /*background-position: 200% 50%;*/
                /*background-size: 200% 100%;*/
                color: inherit;
                display: flex;
                max-height: 4.7em;
                min-height: 4.7em;
                justify-content: space-between;
                padding: 0 1em;
                transition: background 150ms, color 150ms;
            }
            #toolbar.actions-true {
                /*background-position: 50% 50%;*/
                background: var(--actindo-primary);
                color: #fff;
            }

            .sizer {
                bottom: 0;
                cursor: col-resize;
                position: absolute;
                right: 0;
                top: 0;
                width: 6px;
            }
            .sizer.active {
                transform: scale(10, 1.2);
                transform-origin: 50% 50%;
                z-index: 1;
            }

            #paging {
                align-items: center;
                border-top: 1px solid var(--border-color);
                display: flex;
                justify-content: flex-end;
                max-height: 4.15em;
                min-height: 4.15em;
                position: relative;
            }
            #paging[hidden] {
                display: none;
            }

            paper-icon-button[hidden] {
                display: none;
            }
            .empty-message
            {
                @apply(--font-subheader);
                margin: 2em 0 0 2em;
                opacity: 0.72;
            }

            paper-spinner-lite
            {
                --paper-spinner-color: var(--primary-color);
                width: 50px;
                height: 50px;
            }

            .header-bar
            {
                display: flex;
                flex-direction: row;
                @apply(--header-bar-style);
            }
            .header-title
            {
                @apply(--font-subheader);
                opacity: 0.7;
                display: flex;
                align-items: center;
                @apply(--header-title-style);
            }
            
            #actions
            {
                display: flex;
                align-items: center;
            }
            #header-second-line
            {
                display: flex;
                flex-direction: row;
                align-items: center;
                min-height: 3.7em;
                justify-content: space-between;
                padding: 0 1em;
            }
            .header-second-line-icons
            {
                display: flex;
                flex-direction: row;
                align-items: center;
            }
            .header-second-line-content
            {
                display: flex;
            }

            paper-fab {
                background-color: var(--actindo-highlight);
                color: var(--actindo-level0);
                width: 60px;
                height: 60px;
            }

            #gridContainer {
                overflow: hidden;
                position: relative;
                display: flex;
                flex-direction: column;
                z-index: 1;
                flex-grow: 1;
            }
            #createButton {
                position: absolute;
                bottom: 16px;
                right: 16px;
            }
            #gridHeader {
                overflow-x: scroll;
                position: relative;
                border-bottom: 1px solid var(--border-color);
                max-height: 4.7em;
                min-height: 4.7em;
                z-index: 9;
            }
            #gridHeader::-webkit-scrollbar {
                display: none;
            }

            #rowsPerPage {
                margin-right: 10px;
            }
            #rowsPerPage > span {
                margin-right: 10px;

            }

            actindo-grid-filter-columns, actindo-grid-filter
            {
                background-color: var(--menu-background-color);
            }

        </style>

        <div id="toolbar" class$="actions-[[_arrayLengthGT(selectedItems.*, 0)]]">
            <div hidden$="[[!selectedItems.length]]">[[selectedItems.length]] gewählt</div>
            <div hidden$="[[!_arrayLengthEquals(selectedItems.*, 0)]]" class="header-bar">
                <template is="dom-if" if="[[title]]">
                    <div class="header-title">[[title]]</div>
                </template>
                <slot name="toolbar"></slot>
            </div>
            <div hidden$="[[!_arrayLengthEquals(selectedItems.*, 1)]]">
                <slot name="singleActions"></slot>
            </div>
            <div hidden$="[[!_arrayLengthGT(selectedItems.*, 1)]]">
                <slot name="multiActions"></slot>
            </div>
            
            <div id="actions" hidden$="[[_arrayLengthGT(selectedItems.*, 0)]]">
                <slot name="noSelectionActions"></slot>
                <actindo-grid-search query="{{query}}" hidden$="[[_isSearchHidden(remote, _columns.*)]]"></actindo-grid-search>
                <paper-icon-button icon="refresh" hidden$="[[!remote]]" on-tap="_onRefreshTap"></paper-icon-button>

                <template is="dom-if" if="[[_isHeaderSingleMode()]]">
                    <actindo-grid-filter-configurator on-click="_onClickColumnIcon" active="{{_showColumnsArea}}">
                        <paper-icon-button icon="icons:view-column" slot="content"></paper-icon-button>
                        <span slot="content">Columns ([[_displayColumns.length]])</span>
                    </actindo-grid-filter-configurator>

                    <template is="dom-if" if="[[_filterColumns.length]]">
                        <actindo-grid-filter-configurator on-click="_onClickFilterIcon" active="[[_showFilterArea]]">
                            <paper-icon-button icon="icons:filter-list" slot="content"></paper-icon-button>
                            <span slot="content">Filter ([[filterList.length]])</span>
                        </actindo-grid-filter-configurator>
                    </template>
                </template>
            </div>
        </div>

        <template is="dom-if" if="[[!_isHeaderSingleMode()]]">
            <div id="header-second-line">
                <div class="header-second-line-content">
                    <slot name="secondLineContent"></slot>
                </div>
                <div class="header-second-line-icons">
                    <actindo-grid-filter-configurator on-click="_onClickColumnIcon" active="{{_showColumnsArea}}">
                        <paper-icon-button icon="icons:view-column" slot="content"></paper-icon-button>
                        <span slot="content">Columns ([[_displayColumns.length]])</span>
                    </actindo-grid-filter-configurator>

                    <template is="dom-if" if="[[_filterColumns.length]]">
                        <actindo-grid-filter-configurator on-click="_onClickFilterIcon" active="[[_showFilterArea]]">
                            <paper-icon-button icon="icons:filter-list" slot="content"></paper-icon-button>
                            <span slot="content">Filter ([[filterList.length]])</span>
                        </actindo-grid-filter-configurator>
                    </template>
                </div>
            </div>
        </template>

        <template is="dom-if" if="[[_showFilterArea]]">
            <actindo-grid-filter
                filter-list="{{filterList}}"
                filter-columns="{{_filterColumns}}"
                on-inactive-filter-changed="_inactiveFilterChanged"
            >
            </actindo-grid-filter>
        </template>

        <template is="dom-if" if="[[_showColumnsArea]]">
            <actindo-grid-filter-columns columns="{{_columns}}">
            </actindo-grid-filter-columns>
        </template>

        <div id="gridContainer">
            <div id="gridHeader" on-scroll="_onScrollHeader" on-mouseover="_onGridHeaderMouseOver">
                <table id="gridHeaderTable">
                    <thead on-tap="_onHeadTapped">
                        <tr>
                            <template is="dom-if" if="[[_stringEquals(selectionMode, 'multi', 'single')]]" id="toggleAllIf">
                                <th class="checkbox">
                                    <div class="th checkbox">
                                        <paper-checkbox id="toggleAll" partial$="[[_partiallySelected]]" checked="[[_everythingSelected]]" hidden="[[!_stringEquals(selectionMode, 'multi')]]" on-checked-changed="_toggleAllSelection"></paper-checkbox>
                                        &nbsp;
                                    </div>
                                </th>
                            </template>
                            <template is="dom-repeat" items="{{_columns}}" filter="_isColumnVisibile" observe="hidden" id="headerRepeat">
                                <th data-index$="[[index]]" field-name$="[[item.field]]" class$="c[[index]] sortable-[[item.sortable]] is-sorted-[[_isSortedBy(item, sort)]]">
                                    <div class="th">
                                        <span>[[item.label]]</span>
                                        <template is="dom-if" if="[[_evaluatesTrue(item.resizable)]]">
                                            <div class="sizer"></div>
                                        </template>
                                    </div>
                                    [[item.label]]
                                </th>
                            </template>
                            <th class="filler"></th>
                        </tr>
                    </thead>
                </table>
            </div>

            <div id="gridBody" on-scroll="_onScroll" on-mouseover="_onGridBodyMouseOver">
                <table id="table" class$="disable-tap-row-select-[[disableTapRowToSelect]]">
                    <tbody>
                    <template is="dom-repeat" items="[[items]]" as="row">
                        <tr on-tap="_onRowTap"
                            disabled$="[[_propertyEvaluatesTrue(disabledField, row.*)]]"
                            selected$="[[_isItemSelected(row, selectedItems.*)]]"
                            finished$="[[_propertyEvaluatesTrue(finishedField, row.*)]]"
                            locked$="[[_propertyEvaluatesTrue(lockedField, row.*)]]">
                            <template is="dom-if" if="[[_stringEquals(selectionMode, 'multi', 'single')]]">
                                <td class="checkbox">
                                    <paper-checkbox checked="[[_isItemSelected(row, selectedItems.*)]]"></paper-checkbox>
                                    <iron-icon icon="lock"></iron-icon>
                                </td>
                            </template>
                            <template is="dom-repeat" items="{{_columns}}" as="column" filter="_isColumnVisibile" observe="hidden">
                                <td field-name$="[[column.field]]" class$="c[[index]] row-column"><actindo-grid-cell-content row="[[row]]" column="[[column]]"></actindo-grid-cell-content></td>
                            </template>
                            <td></td>
                        </tr>
                    </template>
                    
                    <template is="dom-if" if="[[_error]]">
                        <actindo-grid-error></actindo-grid-error>
                    </template>
                    </tbody>
                </table>
                <template is="dom-if" if="[[!_xhr]]">
                    <template is="dom-if" if="[[!items.length]]">
                        <div class="empty-message">[[emptyMessage]]</div>
                    </template>
                </template>
            </div>
            <template is="dom-if" if="[[_xhr]]">
                <div class="loading">
                    <paper-spinner-lite active></paper-spinner-lite>
                </div>
            </template>
            <template is="dom-if" if="[[showCreateButton]]">
                <paper-fab id="createButton" on-click="_onCreateClick" icon="add" disabled="[[disableCreateButton]]"></paper-fab>
            </template>
        </div>

        <template is="dom-if" if="[[!pagingDisabled]]">
            <div id="paging" hidden="[[!remote]]">
                <div id="rowsPerPage">
                    <span>Rows per page:</span>
                    <select value="{{_itemsPerPage::change}}">
                        <template is="dom-repeat" items="[[itemsPerPageList]]">
                            <option value="[[item]]" selected$="{{_isItemsPerPageSelected(item)}}">[[item]]</option>
                        </template>
                    </select>
                </div>

                [[_getItemsFrom(page, _itemsPerPage, totalItems)]]-[[_getItemsTo(page, _itemsPerPage, totalItems)]] of [[totalItems]]
                <paper-icon-button disabled="[[!_canPageBackward(page)]]" icon="first-page" on-tap="firstPage"></paper-icon-button>
                <paper-icon-button disabled="[[!_canPageBackward(page)]]" icon="chevron-left" on-tap="previousPage"></paper-icon-button>
                <select value="{{page::change}}">
                    <template is="dom-repeat" items="[[_pages]]">
                        <option value="[[item]]">[[item]]</option>
                    </template>
                </select>
                <paper-icon-button disabled="[[!_canPageForward(page, _itemsPerPage, totalItems)]]" icon="chevron-right" on-tap="nextPage"></paper-icon-button>
                <paper-icon-button disabled="[[!_canPageForward(page, _itemsPerPage, totalItems)]]" icon="last-page" on-tap="lastPage"></paper-icon-button>
            </div>
        </template>
    </template>
    <script>
        class ActindoGrid extends Polymer.Element {
            static get is() { return 'actindo-grid'; }

            static get properties() {
                return {
                    /**
                     * contains the columns and their configuration.
                     * * label: the name of this column, used in the header
                     * * field: data index where this columns value is located
                     * * type: the data type of this column, can be any valid javascript type
                     * * identifying: if this column contains a unique key that identifies the single rows. _One_ column must have this if you want to use a selection mode
                     * * hidden: if this column is hidden by default and needs to be enabled manually
                     * * searchable: if this field is searched through the global search field. Defaults to false
                     * * sortable: if the grid can by sorted by this field. Defaults to false
                     * * filterable: if the grid can be filtered by this columns values
                     * * resizable: if this column is resizable
                     * * render: Optional callback that is given the columns value for each row and has to return a DOMElement to be displayed
                     * * renderDefaultFilter: return a DOMElement element to be displayed
                     * * nullMessage: Text shown if field is null; if nothing specified it will display empty string
                     *
                     * @type {[{
                     *     label: string,
                     *     field: string,
                     *     type: mixed,
                     *     identifying: bool,
                     *     hidden: bool,
                     *     searchable: bool,
                     *     sortable: bool,
                     *     filterable: bool,
                     *     resizable: bool,
                     *     render: function,
                     *     renderDefaultFilter: function,
                     *     nullMessage: string
                     * }]}
                     */
                    styleLevel: {
                        type: Number,
                        value: 0,
                        reflectToAttribute: true
                    },


                    columnConfiguration: {
                        type: Array,
                        value: function() {
                        	return [];
                        },
                        notify: true
                    },

                    /**
                     * if grid has no items this message will be shown
                     */
                    emptyMessage: {
                        type: String,
                        value: ""
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is disabled
                     */
                    disabledField: {
                        type: String,
                        value: '_disabled'
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is marked as finished.
                     * This only works with a selection mode enabled since the marker replaces the checkbox
                     */
                    finishedField: {
                        type: String,
                        value: '_finished'
                    },

                    /**
                     * the current page number
                     */
                    page: {
                        type: Number,
                        value: 1,
                        notify: true,
                        observer: '_onPageChanged'
                    },

                    /**
                     * contains the current sorting criteria, the key "field" contains the field name, the field "order" a boolean: true is ASC, false is DESC
                     * {field: String, order: Boolean}
                     */
                    sort: {
                        type: Object,
                        value: function() {
                        	return {};
                        },
                        notify: true,
                        observer: "_onSortChanged"
                    },

                    /**
                     * contains the list of filter of the grid.
                     * * property: the name of the column
                     * * operator: the value of the operator such as (=, like,..)
                     * * value: the value need to be filtered
                     *
                     * @type {[{
                     *     property: string,
                     *     operator: string,
                     *     value: mixed
                     * }]}
                     */
                    filterList: {
                        type: Array,
                        value: function() {
                            return [];
                        },
                        notify: true
                    },

                    /**
                     * contains the current search query
                     */
                    query: {
                        type: String,
                        value: '',
                        notify: true,
                        observer: '_onQueryChanged'
                    },

                    /**
                     * stores the number of total items (over all pages)
                     */
                    totalItems: {
                        type: Number,
                        value: 0,
                        notify: true,
                        readOnly: true
                    },

                    /**
                     * if this is true, the column selection switch is hidden and the user can not enable/disable or rearrange columns
                     */
                    hideColumnConfiguration: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Whether the request debounced or not
                     */
                    debounced: {
                        type: Boolean,
                        value: true
                    },

                    /**
                     * contains all items that are currently in the grid. You can set this property to manually
                     * handle the content of the grid in case you don't want to use the remote loading
                     */
                    items: {
                        type: Array,
                        value: function() {
                        	return [];
                        },
                        notify: true
                    },

                    /**
                     * if an item has a key with this name and contains a value that evaluates to true, that row is marked as locked.
                     */
                    lockedField: {
                        type: String,
                        value: '_locked'
                    },

                    /**
                     * the url to load items from. Alternatively you can use the property `items` to manually add data to the grid,
                     * however that disables the possibility to search, filter, or sort
                     */
                    remote: {
                        type: String,
                        value: null
                    },

                    /**
                     * where the items array is located in the remote response.
                     */
                    remotePathData: {
                        type: String,
                        value: 'data'
                    },

                    /**
                     * where the total count of items is located in the remote response.
                     */
                    remotePathCount: {
                        type: String,
                        value: 'n_rows'
                    },

                    /**
                     * additional url params to be added to the remote url
                     */
                    remoteParams: {
                        type: Object,
                        value: function() {
                        	return {};
                        }
                    },

                    /**
                     * this url param is added to the `remote` url containing the user selected filters
                     */
                    remoteParamFilter: {
                        type: String,
                        value: 'filter'
                    },

                    /**
                     * this url param is added to the `remote` url containing the number of items to be loaded
                     */
                    remoteParamLimit: {
                        type: String,
                        value: 'limit'
                    },

                    /**
                     * this url param is added to the `remote` url containing the requested page
                     */
                    remoteParamOffset: {
                        type: String,
                        value: 'start'
                    },

                    /**
                     * this url param is added to the `remote` url containing the search phrase the user entered
                     */
                    remoteParamSearch: {
                        type: String,
                        value: 'query'
                    },

                    /**
                     * this url param is added to the `remote` url containing the fields that should be searched for `query`
                     */
                    remoteParamSearchFields: {
                        type: String,
                        value: 'fields'
                    },

                    /**
                     * this url param is added to the `remote` url containing the optional fields.
                     */
                    remoteParamSerializeOptionals: {
                        type: String,
                        value: 'serializeOptionals'
                    },

                    /**
                     * this url parameter is added to the `remote` url containing the user selected sorting. Set this
                     * to null to sort the data locally
                     */
                    remoteParamSort: {
                        type: String,
                        value: 'sort'
                    },


                    /**
                     * set to true if results should not be paged
                     */
                    pagingDisabled: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * how rows can be selected. "multi" to allow the selection of n elements, "single" to allow the
                     * selection of only a single element (selecting a new one will deselect the previously selected one).
                     * Any other value will disable the selection model entirely.
                     * If a selection mode is enabled, a checkbox is added to the start of each row
                     */
                    selectionMode: {
                        type: String
                    },

                    /**
                     * if selectionMode=single, this property contains the selected item if one is selected
                     */
                    selectedItem: {
                        type: Object,
                        notify: true,
                        observer: 'onSelectedItemChanged'
                    },

                    /**
                     * contains all the currently selected items
                     */
                    selectedItems: {
                        type: Array,
                        value: function() {
                        	return [];
                        },
                        notify: true
                    },
                    
                    /**
                     * if this is enabled and a selection mode is active, tapping a row will not select it. Rows can then
                     * only be selected by explicitely checking their checkboxes
                     */
                    disableTapRowToSelect: {
                        type: Boolean,
                        value: false
                    },

                    showCreateButton: {
                        type: Boolean,
                        value: false
                    },

                    disableCreateButton: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * List of items per page used for dom-repeat in dropdown
                     */
                    itemsPerPageList: {
                        type: Array,
                        value: function() {
                            return [5, 10, 25, 50, 100];
                        }
                    },


                    /**
                     * internal property that holds the processed columns
                     */
                    _columns: {
                        type: Array,
                        value: function() {
                        	return [];
                        },
                        notify: true
                    },

                    /**
                     * holds the colmumn has filterable is true
                     */
                    _filterColumns: {
                        type: Array,
                        value: function(){return [];}
                    },

                    /**
                     * holds the colmumn that is marked as identifying
                     */
                    _identifyingColumn: {
                        type: Object
                    },

                    /**
                     * holds the column has hidden is false
                     */
                    _displayColumns: {
                        type: Array,
                        value: function(){return [];}
                    },

                    /**
                     * property that controls the checked state of the "select all checkbox" in selectionMode=multi
                     */
                    _everythingSelected: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * property that indicates if a partial selection is active (at least one item, but not all)
                     */
                    _partiallySelected: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * current xhr request
                     */
                    _xhr: {
                        type: Object
                    },

                    /**
                     * property that indicates if a xhr request is failed
                     */
                     _error: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * List of pages used for dom-repeat in dropdown to change current page
                     */
                    _pages: {
                        type: Array,
                        value: function(){return [];}
                    },

                    /**
                     * how many items to show per page
                     */
                    _itemsPerPage: {
                        type: Number,
                        value: 25,
                        observer: '_onItemsPerPageChanged'
                    },

                    /**
                      * List of the optional column. The hidden column will not be in this list
                     */
                    _serializeOptionals: {
                        type: Array,
                        value: function(){return [];}
                    },

                    /**
                      * List of the loaded column
                     */
                    _loadedColumns: {
                        type: Array,
                        value: function(){return [];}
                    },

                    /**
                     * the title will show on headline
                     */
                    title: {
                        type: String,
                    },

                    /**
                      * internal property, the title  will show on headline
                     */
                    header: {
                        type: String,
                    },

                    /**
                      * internal property, set to true if the filter area will show
                     */
                    _showFilterArea: {
                        type: Boolean,
                        value: false,
                        notify: true
                    },

                    /**
                      * internal property, set to true if the columns area will show
                     */
                    _showColumnsArea: {
                        type: Boolean,
                        value: false,
                        notify: true
                    },

                    /**
                      * property that indicates header will display one line (single) or two line (multi)
                     */
                    multiLineHeader: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * internal property, set to true if it is processing init layout
                     */
                    _isProcessingInitLayout: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * internal property, whether first time render layout or not
                     */
                     _isFirstTimeRenderLayout: {
                        type: Boolean,
                        value: true
                    }
                }
            }

            /*
             * public api
             */

            /**
             * loads the first page
             */
            firstPage() {
                this.page = 1;
            }

            /**
             * loads the last page
             */
            lastPage() {
                this.page = Math.max(1, Math.ceil(this.totalItems / this._itemsPerPage));
            }

            /**
             * loads the next page
             */
            nextPage() {
                this.page = Math.max(1, Math.min(this.page + 1, Math.ceil(this.totalItems / this._itemsPerPage)));
            }

            /**
             * loads the previous page
             */
            previousPage() {
                this.page = Math.max(1, this.page - 1);
            }

            /**
             * reloads the grid data from the remote
             */
            refresh(debounced = true) {
                if( !this.remote )
                {
                    return;
                }
                if (!debounced)
                {
                    this._load(
                        this.remote,
                        this.remotePathData,
                        this.remotePathCount,
                        this.remoteParams,
                        this.remoteParamFilter,
                        this.remoteParamLimit,
                        this.remoteParamOffset,
                        this.remoteParamSearch,
                        this.remoteParamSearchFields,
                        this.remoteParamSort,
                        this.remoteParamSerializeOptionals,
                        this._itemsPerPage,
                        this.page,
                        this.sort,
                        this.query,
                        this.filterList,
                        this._serializeOptionals
                    );
                    return;
                }
                this._loadDebounced(
                        this.remote,
                        this.remotePathData,
                        this.remotePathCount,
                        this.remoteParams,
                        this.remoteParamFilter,
                        this.remoteParamLimit,
                        this.remoteParamOffset,
                        this.remoteParamSearch,
                        this.remoteParamSearchFields,
                        this.remoteParamSort,
                        this.remoteParamSerializeOptionals,
                        this._itemsPerPage,
                        this.page,
                        this.sort,
                        this.query,
                        this.filterList,
                        this._serializeOptionals
                );
            }

            /**
             * Removes all filters
             */
            clearFilters()
            {
                this.set( "filterList", [] );
            }

            /**
             * Returns list of all filters (active/inactive)
             * @return {Array}
             */
            getFilters()
            {
                return this.filterList;
            }

            /**
             * Adds a filter
             * @param {String} field
             * @param {String} operator
             * @param {*} value
             * @param {Boolean} active
             * @return {Boolean} success
             */
            addFilter( field, operator, value, active )
            {
                const index = this._columnIndexByFieldName[field];
                if( index === undefined || !this._columns[index].filterable )
                {
                    return false;
                }
                this.push( "filterList", {
                    property: field,
                    operator: operator,
                    value: value,
                    active: active
                } );
                return true;
            }

            /**
             * Returns array containing all fields that are visible
             * @return {Array}
             */
            getVisibleFields()
            {
                let ret = [];
                for(let i=0;i<this._columns.length;i++)
                {
                    let column = this._columns[i];
                    if( column.hidden === false )
                    {
                        ret.push( column.field );
                    }
                }
            }

            /**
             * @param {String} fieldName
             * Shows column with corresponding fieldName if existing
             */
            showColumnByFieldName( fieldName )
            {
                if( this._columnIndexByFieldName[fieldName] !== undefined )
                {
                    this.set( '_columns.'+this._columnIndexByFieldName[fieldName]+'.hidden', false );
                }
            }

            /**
             * Hides column with corresponding fieldName if visible
             */
            hideColumnByFieldName( fieldName )
            {
                if( this._columnIndexByFieldName[fieldName] !== undefined)
                {
                    this.set( '_columns.'+this._columnIndexByFieldName[fieldName]+'.hidden', true );
                }
            }


            /*
             * lifecycle and initialization
             */

            static get observers() {
                return [
                    '_consolidateColumns(columnConfiguration.*)',
                    '_onItemsChanged(items.*)',
                    '_onSelectionChanged(selectedItems.*)',
                    '_onRemoteChanged(remote, remotePathData, remotePathCount, remoteParams, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, remoteParamSerializeOptionals, _itemsPerPage, page, sort, query, filterList, _serializeOptionals.*)',
                    '_onFilterChanged(filterList.*)',
                    '_onColumnConfigurationChanged(_columns.*)'
                ];
            }

            ready() {
                super.ready();
                let me = this;

                window.setTimeout(function() {
                    me._initColumnResizing();
                }, 0);
            }

            /**
             * returns the default configuration for a column
             *
             * @returns {{}}
             */
            static get columnDefaults() {
                return {
                    label: '',
                    field: '',
                    type: String,
                    identifying: false,
                    hidden: false,
                    searchable: false,
                    sortable: false,
                    filterable: false,
                    resizable: true,
                    render: null,
                    defaultFilterProperties: {},
                    renderDefaultFilter: function(properties = {}, operator) {
                        let element;
                        const betweenKey = ActindoGridFilterHelper.operators.between.key;
                        const inKey = ActindoGridFilterHelper.operators.in.key;
                        const equalInOptionKey = ActindoGridFilterHelper.operators.equal_in_option.key;

                        switch(operator.key)
                        {
                            case betweenKey:
                                element = document.createElement('actindo-grid-filter-between-input');
                                break;
                            case inKey:
                                element = document.createElement('actindo-grid-filter-in-input');
                                break;
                            case equalInOptionKey:
                                element = document.createElement('actindo-grid-filter-in-option-input');
                                break;
                            default:
                                element = document.createElement('paper-input');
                                break;
                        }
                        element.label = 'Value';
                        Object.assign(element, properties);
                        return element;
                    }
                };
            }

            /**
             * Moves columns to new position
             * @param {String} fieldName
             * @param {Number} newIndex
             */
            setColumnToPositionIndex( fieldName, newIndex )
            {
                //Important because we can ensure that async updated _columnIndexByFieldName is correct
                window.setTimeout(
                    () => {
                        const oldIndex = this._columnIndexByFieldName[fieldName];
                        if( oldIndex !== undefined && oldIndex !== false )
                        {
                            this.splice( '_columns', newIndex, 0, this.splice( '_columns', oldIndex, 1)[0]);
                        }
                    }, 0
                );
            }

            /**
             * Get width in px of a column
             * @return {String}
             */
            getColumnWidth( fieldName )
            {
                const dom = Polymer.dom(this.root);
                fieldName = fieldName.replace( ".", "\\." );
                const headerColumns = dom.querySelector('#gridHeader th[field-name='+fieldName+']');
                let paddingLeftRight =
                    parseFloat(window.getComputedStyle(headerColumns,null).getPropertyValue( 'padding-left' ))
                    +parseFloat(window.getComputedStyle(headerColumns,null).getPropertyValue( 'padding-right' ));
                return headerColumns ? headerColumns.clientWidth - paddingLeftRight : null;
            }

            /**
             * @param {String} fieldName field of the column to be resized
             * @param {Number} width in px
             */
            setColumnWidth( fieldName, width )
            {
                if( this._columnIndexByFieldName[fieldName] !== undefined && this._columns[this._columnIndexByFieldName[fieldName]].resizable === true )
                {
                    const dom = Polymer.dom(this.root);
                    fieldName = fieldName.replace( ".", "\\." );
                    let resizingColumns = dom.querySelectorAll('td[field-name='+fieldName+'],th[field-name='+fieldName+']');
                    this._resizeColumn( resizingColumns, width );
                }
            }

            _onRefreshTap()
            {
                this.refresh(false);
            }

            _onScroll(e) {
                if (this.scrollingItem !== 'body')
                {
                    return;
                }
                this.$.gridHeader.scrollLeft = e.target.scrollLeft;
            }

            /**
             * @private
             */
            _onScrollHeader(e) {
                if (this.scrollingItem !== 'header')
                {
                    return;
                }
                this.$.gridBody.scrollLeft = e.target.scrollLeft;
            }

            /**
             * @private
             */
            _onGridHeaderMouseOver()
            {
                this.scrollingItem = 'header';
            }

            /**
             * @private
             */
            _onGridBodyMouseOver()
            {
                this.scrollingItem = 'body';
            }

            /**
             * @private
             */
            _positionCreateButton() {
                if (!this.showCreateButton) return;

                const dom = Polymer.dom(this.root);
                const gridBody = dom.querySelector('#gridBody');

                if (gridBody.scrollWidth > gridBody.clientWidth) {
                    this.shadowRoot.querySelector('#createButton').style.bottom = '21px';
                }

                if (gridBody.scrollHeight > gridBody.clientHeight) {
                    this.shadowRoot.querySelector('#createButton').style.right = '21px';
                }
            }

            /**
             * @private
             */
            _initLayout() {
                if (this._isProcessingInitLayout) return;

                this._isProcessingInitLayout = true;

                const dom = Polymer.dom(this.root);

                let interval = window.setInterval(() => {
                    // Make sure data loaded
                    if (this._xhr) {
                        return;
                    }


                    const totalVisibleColumns = this._displayColumns.length;
                    const headerColumns = dom.querySelectorAll('#gridHeader th[data-index]');
                    const rowColumns = dom.querySelectorAll('#table tr:first-child td.row-column');

                    // Skip if we have no column in configuration
                    if (!totalVisibleColumns) {
                        window.clearInterval(interval);
                        this._isProcessingInitLayout = false;
                        return;
                    }

                    // Reset header columns width
                    if (!this.items.length) {
                        for (let i = 0, l = headerColumns.length; i < l; i++) {
                            headerColumns[i].setAttribute('style', '');
                        }

                        window.clearInterval(interval);
                        this._isProcessingInitLayout = false;
                        return;
                    }

                    // Make sure all headers and rows rendered
                    if ((totalVisibleColumns !== headerColumns.length) || (totalVisibleColumns !== rowColumns.length)) {
                        return;
                    }

                    // Make sure all data rendered
                    const rows = dom.querySelectorAll('#gridBody #table tr');
                    if (rows.length !== this.items.length) {
                        return;
                    }

                    // Resize headers & columns
                    for (let i = 0; i < totalVisibleColumns; i++) {
                        const headerColumnWidth = headerColumns[i].clientWidth;
                        const rowColumnWidth = rowColumns[i].clientWidth;
                        let width;

                        // Make sure the header and column container are visible
                        if (!headerColumnWidth || !rowColumnWidth) {
                            return;
                        }
                        window.clearInterval(interval);
                        const field = this._displayColumns[i].field;
                        if( this.widthByFieldName && this.widthByFieldName[field] )
                        {
                            this.setColumnWidth( field, this.widthByFieldName[field] );
                            continue;
                        }
                        // If first time render and the column configuration has min-width
                        else if (this._displayColumns[i].minWidth && this._isFirstTimeRenderLayout)
                        {
                            width = this._displayColumns[i].minWidth - 19.5;
                        }
                        else if (headerColumnWidth > rowColumnWidth) {
                            width = headerColumnWidth - 19.5;
                        } else {
                            width = rowColumnWidth - 19.5;
                        }
                        
                        const styleString = 'max-width: ' + width + 'px; min-width: ' + width + 'px; width: ' + width + 'px';
                        headerColumns[i].setAttribute('style', styleString);
                        rowColumns[i].setAttribute('style', styleString);

                        this.widthByFieldName = {};
                    }
                    this._isFirstTimeRenderLayout = false;

                    this._positionCreateButton();
                    this._isProcessingInitLayout = false;
                    for( let i = 0; i < this._displayColumns.length ; i++ )
                    {
                        this.widthByFieldName[this._displayColumns[i].field] = this.getColumnWidth( this._displayColumns[i].field );
                    }
                }, 50);
            }

            /**
             * sets up the column resizing handlers
             * @private
             */
            _initColumnResizing() {
                let me = this;

                this.resizingColumns = undefined;
                this.resizingColumnOffset = 0;
                this.resizingHandle = undefined;
                this.$.gridHeader.addEventListener('mousedown', function(e) {
                    if(e.target.classList && e.target.classList.contains('sizer')) {
                        e.target.classList.add('active');
                        me.resizingHandle = e.target;
                        let column = e.target.parentNode.parentNode;
                        let selectIndex = column.getAttribute('data-index');
                        me.resizingColumns = Polymer.dom(me.root).querySelectorAll('.c' + selectIndex);
                        me.resizingColumnOffset = column.offsetWidth - e.pageX;
                    }
                });

                document.addEventListener('mousemove', function(e) {
                    if (me.resizingColumns && me.resizingColumns.length) {
                        let paddedWidth = Math.max(me.resizingColumnOffset + e.pageX, 32);
                        if( !me._paddingLeftRight )
                        {
                            me._paddingLeftRight =
                                parseFloat(window.getComputedStyle(me.resizingColumns[0],null).getPropertyValue( 'padding-left' ))
                                +parseFloat(window.getComputedStyle(me.resizingColumns[0],null).getPropertyValue( 'padding-right' ));
                        }
                        let width = paddedWidth - me._paddingLeftRight;
                        me._resizeColumn( me.resizingColumns, width );
                    }
                });

                document.addEventListener('mouseup', function(e) {
                    me.resizingColumns = undefined;
                    if (me.resizingHandle) {
                        me.resizingHandle.classList.remove('active');
                    }
                    me.resizingHandle = undefined;
                });
            }

            /**
             * Performs column resizing;
             * @param {Array} list of table cells of that column in all rows and header
             * @param {Number} width in px
             */
            _resizeColumn( list, width )
            {
                if( typeof this.widthByFieldName !== 'object' )
                {
                    this.widthByFieldName = {};
                }
                let styleText = 'width: ' + width + 'px; min-width: ' + width + 'px; max-width: ' + width + 'px;';
                for (let i = 0, c = list.length; i < c; i++) {
                    list[i].setAttribute('style', styleText);
                    if( i === 0 ) //Once is enough
                    {
                        this.widthByFieldName[list[i].getAttribute( 'field-name' )] = width;
                    }
                }
                this._resizeDebouncer = Polymer.Debouncer.debounce( //Important to resize because called by mousemove event
                    this._resizeDebouncer,
                    Polymer.Async.timeOut.after(500),
                    () => {
                    this.dispatchEvent(  new CustomEvent( "after-resize" ) );
                } )
            }

            /**
             * Initialize sorting
             * @param {String} fieldName
             * @param {String} order ASC or DESC not case sensitive
             */
            setSortOrder( fieldName, order )
            {
                order = order.toLowerCase();
                if( order !== 'asc' && order !== 'desc' )
                {
                    throw "Unknown sort order";
                }
                if( !this._columnIndexByFieldName[fieldName] === undefined )
                {
                    throw "Unknown field";
                }
                let column = this._columns[this._columnIndexByFieldName[fieldName]];
                if( !column.sortable )
                {
                    throw "Column not sortable"
                }
                this.set( "sort", {field:fieldName, order: order === 'asc' } );
            }

            removeSorting()
            {
                this.set( 'sort', {} );
            }

            /*
             * event callbacks
             */

            _onSortChanged()
            {
                this.dispatchEvent( new CustomEvent( 'sort-changed' ) );
            }

            _inactiveFilterChanged()
            {
                this.dispatchEvent( new CustomEvent( "inactive-filter-changed", {} ) );
            }

            /**
             * called when the table head is tapped. Check if the tapped column is sortable and if so, sort by it
             * @private
             */
            _onHeadTapped(e) {
                let column;
                for(let i = 0, c = e.path.length; i < c; i++) {
                    if(i > 5 || !e.path[i].classList) {
                        return;
                    }
                    if(e.path[i].classList.contains('sortable-true')) {
                        column = e.path[i];
                        break;
                    }
                }
                let realIndex = -1;
                let countNonHidden = 0;
                let columnCurrentIndex = Number(column.getAttribute('data-index'));
                for(let i=0;i<this._columns.length;i++)
                {
                    if( !this._columns[i].hidden )
                    {
                        ++countNonHidden;
                    }
                    if( countNonHidden === columnCurrentIndex+1 )
                    {
                        realIndex = i;break;
                    }
                }
                if( realIndex < 0 )
                {
                    console.warn("could not find column index");
                    return;
                }
                column = this._columns[realIndex];
                if(column)
                {
                    let field = column.field;
                    if(!this.sort.hasOwnProperty('field'))
                    {
                        // currently no sorting, sort by the given column ASC
                        this.set('sort', {field: field, order: true});
                    }
                    else
                    {
                        // a sorting is defined
                        if(this.sort.field !== field) {
                            // currently sorted by differen field, sort by this field asc
                            this.set('sort', {field: field, order: true});
                        }
                        else if(this.sort.order === true) {
                            // currently sorted asc by this field, sort desc by this field now
                            this.set('sort', {field: field, order: false});
                        }
                        else {
                            // currently sorted desc by this field, remove sorting
                            this.set('sort', {});
                        }
                    }
                }
            }

            /**
             * called when the property `query` changes. Set page to 1
             * @private
             */
            _onQueryChanged() {
                this.firstPage();
            }

            /**
             * called when a row in the table is tapped. If row tapping should select the row and a selection mode
             * is active, the tapped row is selected
             * @private
             */
            _onRowTap(e) {
                e.stopPropagation();
                if(!this.selectionMode || (e.target.tagName !== 'PAPER-CHECKBOX' && this.disableTapRowToSelect))
                {
                    return;
                }
                let index = e.model.index;
                let row = this.items[index];

                if(this._propertyEvaluatesTrue(this.disabledField, this.items[index])) {
                    // field is disabled, no interaction possible
                    return;
                }
                if(this._propertyEvaluatesTrue(this.lockedField, this.items[index])) {
                    // field is locked, no interaction possible
                    return;
                }

                let rowSelectedIndex = this.selectedItems.indexOf(row);
                if(rowSelectedIndex > -1)
                {
                    this.splice('selectedItems', rowSelectedIndex, 1);
                    this.set('selectedItem', null);
                }
                else
                {
                    if(this.selectionMode === 'single') {
                        this.set('selectedItems', [this.items[index]]);
                        this.set('selectedItem', this.items[index]);
                    }
                    else
                    {
                        this.push('selectedItems', this.items[index]);
                    }
                }
            }

            /**
             * called when the selected item changes (selection mode = single). Updates the selectedItems property
             *
             * @param {{}} newVal the newly selected item
             */
            onSelectedItemChanged(newVal) {
                if(this.selectionMode !== 'single') {
                    return;
                }

                if(newVal) {
                    this.set('selectedItems', [newVal]);
                }
                else {
                    this.set('selectedItems', []);
                }
            }

            /**
             * called when the "select all" checkbox is tapped. Toggles the selection of all items
             * @private
             */
            _toggleAllSelection() {
                if(this._everythingSelected)
                {
                    this.set('selectedItems', []);
                }
                else
                {
                    if(!this.items) {
                        this.set('selectedItems', []);
                    }
                    else {
                        let selected = [];
                        for(let i = 0, c = this.items.length; i < c; i++)
                        {
                            selected.push(this.items[i]);
                        }
                        this.set('selectedItems', selected);
                    }
                }
            }

            /**
             * called when the items property changes. Move it to _items and make sure to properly
             * propagate the change.
             * Unfortunately a copy of th original item has to be created to make polymer aware of this change.
             *
             * @param {{path: String, base: []}} change
             * @private
             */
            _onItemsChanged(change) {
                let me = this;

                me._initLayout();

                // update selectedItems: check if the items that were selected are still the grid and are not disabled or locked
                this.__selectionDebounce = this.__selectionDebounce | 0;
                window.clearTimeout(this.__selectionDebounce);
                this.__selectionDebounce = window.setTimeout(function() {
                    let newSelectedItems = [];
                    me.selectedItems.forEach(function(item) {
                        if(me.items.indexOf(item) !== -1) {
                            if(me._propertyEvaluatesTrue(me.lockedField, item)) {
                                // item is locked, no longer selected
                                return;
                            }
                            if(me._propertyEvaluatesTrue(me.disabledField, item)) {
                                // item is disabled, no longer selected
                                return;
                            }
                            newSelectedItems.push(item);
                        }
                    });
                    if(me.selectedItem && newSelectedItems.indexOf(me.selectedItem) === -1) {
                        // selectedItem is no longer in the array of selected items (and therefor not in the grid, remove it)
                        me.set('selectedItem', null);
                    }
                    me.set('selectedItems', newSelectedItems);
                }, 5);
                if( this._itemsPerPage > 0 && this.totalItems && this.remote )
                {
                    let pages = [];
                    for(let i=1;i<=Math.ceil(this.totalItems / this._itemsPerPage);i++)
                    {
                        pages.push(i);
                    }
                    this.set("_pages", pages);
                }

            }

            /**
             * called when a new page is set. Make sure it's within the possible bounds
             *
             * @param {Number} newVal
             * @private
             */
            _onPageChanged(newVal) {
                if(this.totalItems > 0 && this._itemsPerPage > 0)
                {
                    this.page = Math.max(1, Math.min(this.page, Math.ceil(this.totalItems / this._itemsPerPage)));
                }
            }

            /**
             * called when the selected items change. Fires an event
             * @private
             */
            _onSelectionChanged() {
                this._everythingSelected = (this.selectedItems.length > 0 && this.selectedItems.length === this.items.length);
                this._partiallySelected = this.selectedItems.length > 0 && !this._everythingSelected;
                this.dispatchEvent(new CustomEvent('selected-items-changed', {detail: {path: 'selectedItems', value: this.selectedItems}}));
            }

            /**
             * attach operator property to column object
             * @private
             */
            _attachOperatorToColumn(item)
            {

                const column = Object.assign({}, item);

                item.defaultFilterProperties.inputType = item.defaultFilterProperties.inputType || column.type.name;

                column.operators = ActindoGridFilterHelper.operatorList[item.defaultFilterProperties.inputType] || [];

                if (column.customFilter)
                {
                    column.operators = column.customFilter.operators || [];
                }

                if (column.operators.length === 0)
                {
                    column.operators = ActindoGridFilterHelper.operatorList.default;
                }

                return column;
            }


            /**
             * call when column configuration change
             * @private
             */
            _onColumnConfigurationChanged(columns)
            {
                let displayColumns = this._columns.filter(item => item.hidden === false);

                this._columnIndexByFieldName = {};
                for(let i=0;i<columns.base.length;i++)
                {
                    this._columnIndexByFieldName[columns.base[i].field] = i;
                }
                this.set('_displayColumns', displayColumns);

                this._initLayout();

                // need to remove column field in optional list if it changed to hidden
                const hiddenOptionalColumns = this._columns.filter(item => item.hidden && this._serializeOptionals.includes(item.field));
                hiddenOptionalColumns.forEach(column => {
                    const index = this._serializeOptionals.findIndex( item => item === column.field);
                    this._serializeOptionals.splice(index, 1);
                });

                // Do not reload if there isn't any new optional column shown
                const optionalColumns = this._displayColumns.filter( item => item.optional && !this._serializeOptionals.includes(item.field) && !this._loadedColumns.includes(item.field))
                if (optionalColumns.length === 0)
                {
                    return;
                }
                
                const optionalColumnFields = optionalColumns.map(item => item.field);
                this.push('_serializeOptionals', ...optionalColumnFields);
            }

            _checkIdentifyColumn(column)
            {
                if (!column.identifying)
                {
                    return;
                }

                if(this._identifyingColumn !== null)
                {
                    console.warn('more than one identifying columns given, ignoring this', column);
                    return;
                }

                this._identifyingColumn = column;
            }

            /**
             * called when the columnConfiguration changes. Process the columns and copy them to the internal
             * _columns property.
             *
             * @param {{base: []}} columnConfiguration
             * @private
             */
            _consolidateColumns(columnConfiguration) {
                let configurations = columnConfiguration.base;
                let filterColumns = [];
                let serializeOptionals = [];
                this._identifyingColumn = null;
                const columns = configurations.map((configuration) => {
                    let column = ActindoGrid.columnDefaults;
                    Object.assign(column, configuration);

                    if (column.filterable)
                    {
                        const filterColumn = this._attachOperatorToColumn(column);
                        filterColumns.push(filterColumn);
                    }

                    if (column.optional && !column.hidden)
                    {
                        serializeOptionals.push(column.field);
                    }

                    this._checkIdentifyColumn(column);

                    return column;
                });

                if(this._identifyingColumn === null && this.selectionMode) {
                    console.warn('no identifying column given, disabling selection model', columns);
                    this.selectionMode = null;
                }

                this._columns = columns;
                this._columnIndexByFieldName = {};
                for(let i=0;i<columns.length;i++)
                {
                    this._columnIndexByFieldName[columns[i].field] = i;
                }
                this._filterColumns = filterColumns;
                this._serializeOptionals = serializeOptionals;
                
            }

            _load(remote, remotePathData, remotePathCount, remoteParams, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, remoteParamSerializeOptionals, itemsPerPage, page, sort, query, filter, serializeOptionals)
            {

                if( !remote )
                {
                    return;
                }
                let me = this;
                let request = remoteParams;
                this._error = false;
                if( !this.pagingDisabled )
                {
                    // pagination
                    request[remoteParamLimit] = itemsPerPage;
                    request[remoteParamOffset] = (page - 1) * itemsPerPage;
                }

                // sorting
                request[remoteParamSort] = [];
                if(sort.hasOwnProperty('field')) {
                    request[remoteParamSort].push({field: sort.field, order: sort.order ? 'ASC' : 'DESC'});
                }

                request[remoteParamFilter] = [];
                if(filter.length > 0) {
                    filter.forEach(item => {
                        if (item.active)
                        {
                            request[remoteParamFilter].push(item)
                        }
                    });
                }

                request[this.remoteParamSerializeOptionals] = serializeOptionals;

                // searching
                if(query.length) {
                    request[remoteParamSearch] = query;
                    request[remoteParamSearchFields] = [];
                    for(let i = 0, c = me._columns.length; i < c; i++) {
                        let column = me._columns[i];
                        if(column.searchable) {
                            request[remoteParamSearchFields].push(column.field);
                        }
                    }
                }
                else {
                    request[remoteParamSearch] = "";
                }

                if( this._xhr )
                {
                    this._xhr.abort();
                }

                this.set('_loadedColumns', [].concat(this._serializeOptionals));

                this._xhr = new XMLHttpRequest();
                this._xhr.open("POST", remote, true);
                this._xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this._xhr.onreadystatechange = function() {
                    if(me._xhr.readyState === XMLHttpRequest.DONE) {
                        if( me._xhr.status === 200 )
                        {
                            let data = JSON.parse(me._xhr.responseText);
                            me._setTotalItems(Polymer.Path.get(data, remotePathCount));
                            me.items = Polymer.Path.get(data, remotePathData);
                            me.dispatchEvent( new CustomEvent( "after-load", {detail: data} ) );
                        }
                        else if( me._xhr.status !== 0 )
                        {

                            me._xhr = null;
                            me._error = true;
                            console.error(me.xhr.response);
                        }
                        me._xhr = null;
                    }
                };
                this._xhr.send(me._serialize(request));
            }

            _onFilterChanged(filterList)
            {
                // Ignore filterList.length event
                if (filterList.path === 'filterList.length')
                {
                    return;
                }
                // Ignore if all the splice item are inactive
                if (filterList.value.indexSplices)
                {
                    const {removed} = filterList.value.indexSplices[0];
                    const activeFilter = removed.find(item => item.active === true);
                    if (removed.length > 0 && !activeFilter)
                    {
                        return;
                    }
                }
                if (this.page === 1)
                {
                    this.refresh();
                    return;
                }
                this.firstPage();
            }
            /**
             * called on explicit refresh or if any of the parameter changes that require a reload from the remote
             *
             * @private
             */
            _onRemoteChanged(remote, remotePathData, remotePathCount, remoteParams, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, remoteParamSerializeOptionals, itemsPerPage, page, sort, query, filterList = [], serializeOptionals) {
                if(!remote) {
                   return;
                }
                
                this.refresh();
            }

            _loadDebounced(remote, remotePathData, remotePathCount, remoteParams, remoteParamFilter, remoteParamLimit, remoteParamOffset, remoteParamSearch, remoteParamSearchFields, remoteParamSort, remoteParamSerializeOptionals, itemsPerPage, page, sort, query, filterList, serializeOptionals) {
               this._debouncer = Polymer.Debouncer.debounce(this._debouncer,
                  Polymer.Async.timeOut.after(500),
                   () => {
                       this._load(
                           remote,
                           remotePathData,
                           remotePathCount,
                           remoteParams,
                           remoteParamFilter,
                           remoteParamLimit,
                           remoteParamOffset,
                           remoteParamSearch,
                           remoteParamSearchFields,
                           remoteParamSort,
                           remoteParamSerializeOptionals,
                           itemsPerPage,
                           page,
                           sort,
                           query,
                           filterList,
                           serializeOptionals
                       );
                   }
               );
            }

            /**
             * Called when create button clicked
             *
             * @private
             */
            _onCreateClick() {
                this.dispatchEvent( new CustomEvent( "create-clicked" ) );
            }

            /**
             * @private
             */
            _onItemsPerPageChanged() {
                const lastPage = Math.max(1, Math.ceil(this.totalItems / this._itemsPerPage));
                if (this.page > lastPage) {
                    this.page = lastPage;
                }
            }

            /**
             * @private
             */
            _isItemsPerPageSelected(selectedItem) {
                return this._itemsPerPage === selectedItem;
            }

            /*
             * internal helpers
             */

            /**
             * takes the given object and creates an http query string from it
             * usage: let str = _serialize({foo: 'bar', baz: ['a', 'b']}); => 'foo=bar&baz[0]=a&baz[1]=b'
             *
             * @param {{}} obj the object to serialize
             * @param {String} prefix internal only (used in recursive calls for nested objects)
             * @returns {String}
             * @private
             */
            _serialize(obj, prefix) {
                var str = [], p;
                for(p in obj) {
                    if (obj.hasOwnProperty(p)) {
                        var k = prefix ? prefix + "[" + p + "]" : p, v = obj[p];
                        str.push((v !== null && typeof v === "object") ?
                            this._serialize(v, k) :
                            encodeURIComponent(k) + "=" + encodeURIComponent(v));
                    }
                }
                return str.join("&");
            }

            /*
             * template helpers
             */

            _arrayLengthEquals(items, equals) {
                if(items.hasOwnProperty('base') && Array.isArray(items.base))
                {
                    items = items.base;
                }

                return items.length === equals;
            }

            _arrayLengthGT(items, gt) {
                if(items.hasOwnProperty('base') && Array.isArray(items.base))
                {
                    items = items.base;
                }

                return items.length > gt;
            }

            /**
             * checks if the user can page backwards
             *
             * @param {Number} page the current page
             * @returns {Boolean}
             * @private
             */
            _canPageBackward(page) {
                return page > 1;
            }

            /**
             * checks if the user can page forwards
             *
             * @param {Number} page the current page
             * @param {Number} itemsPerPage how many items per page should be shown
             * @param {Number} totalItems how mnay items are in the grid in total
             * @returns {Boolean}
             * @private
             */
            _canPageForward(page, itemsPerPage, totalItems) {
                return this._getItemsTo(page, itemsPerPage, totalItems) < totalItems;
            }

            /**
             * calculates the offset for the pagination query
             *
             * @param {Number} page the page to calculate the offset for
             * @param {Number} itemsPerPage how many items per page should be shown
             * @returns {Number}
             * @private
             */
            _getItemsFrom(page, itemsPerPage, totalItems) {
                return Math.min(totalItems, (page - 1) * itemsPerPage + 1);
            }

            /**
             * returns the index of the last item on the given page
             * @param {Number} page the pag to calculate the last index for
             * @param {Number} itemsPerPage how many items per page should be shown
             * @param totalItems
             * @private
             */
            _getItemsTo(page, itemsPerPage, totalItems) {
                return Math.min(page * itemsPerPage, totalItems);
            }

            /**
             * checks if the given value evaluates to true
             *
             * @param value
             * @returns {boolean}
             * @private
             */
            _evaluatesTrue(value) {
                return Boolean(value);
            }

            /**
             * determines if the given column is visible
             *
             * @param {{hidden: bool}} column
             * @returns {boolean}
             * @private
             */
            _isColumnVisibile(column) {
                return !column.hidden;
            }

            /**
             * checks if the given item is selected
             *
             * @param {{}} item one item from the current data array
             * @param {[]} selectedItems an array of currently selected items
             * @returns {boolean}
             * @private
             */
            _isItemSelected(item, selectedItems) {
                return selectedItems.base.indexOf(item) > -1;
            }

            /**
             * checks if the grid search should be hidden. This is the case when no remote is configured
             * or if no column is marked as searchable
             *
             * @param {String} remote
             * @param {{}} columns
             * @returns {boolean}
             * @private
             */
            _isSearchHidden(remote, columns) {
                if(!remote) {
                    return true;
                }
                if(columns.hasOwnProperty('base') && Array.isArray(columns.base)) {
                    for(let i = 0, c = columns.base.length; i < c; i++) {
                        if(columns.base[i].searchable) {
                            return false;
                        }
                    }
                }

                return true;
            }
            
            /**
             * checks if the grid is currently sorted by the given column
             *
             * @param {{field: String}} column the column to check
             * @param {{field: String}} sort the current sorting array
             * @returns {Boolean}
             * @private
             */
            _isSortedBy(column, sort) {
                if(sort.hasOwnProperty('field') && sort.field === column.field) {
                    return sort.order;
                }

                return null;
            }

            /**
             * determines if the given field evaluates to true in the given item.
             *
             * @param {String} field
             * @param {{}} item
             */
            _propertyEvaluatesTrue(field, item) {
                if(item.hasOwnProperty('base')) {
                    item = item.base;
                }

                if(item.hasOwnProperty(field)) {
                    return Boolean(item[field]);
                }

                return false;
            }

            /**
             * checks if the given string equals one or more given strings. The first given parameter is the value to
             * look for, it is compared with oll other given params and if one of them matches, true is returned; otherwise
             * false
             *
             * @returns {boolean}
             * @private
             */
            _stringEquals() {
                let test = arguments[0];
                for(let i = 1, c = arguments.length; i < c; i++)
                {
                    if(arguments[i] === test)
                    {
                        return true;
                    }
                }

                return false;
            }

            /**
             * when click filter icon will show or hide filter area
             */
            _onClickFilterIcon() {
                this.set('_showColumnsArea', false);
                this.set('_showFilterArea', !this._showFilterArea);
            }

            /**
             * when click column icon will show or hide columns area
             */
            _onClickColumnIcon() {
                this.set('_showFilterArea', false);
                this.set('_showColumnsArea', !this._showColumnsArea);
            }

            /**
             * check header mode display is single or multi, default is single
             * 
             */
            _isHeaderSingleMode() {
                return !this.multiLineHeader;
            }
        }

        customElements.define(ActindoGrid.is, ActindoGrid);
    </script>
</dom-module>
